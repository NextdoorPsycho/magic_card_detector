#!/bin/bash

# ------------------------------------------------------------------------------
# Script: combine_dart_files.sh
# Description:
#   Combines .dart files from the 'lib' directory into multiple output files,
#   each capped at a target file size. Certain files and patterns are ignored.
#   Deletes previously generated output files before starting.
# ------------------------------------------------------------------------------

# === Configuration ===
IGNORE_FILES=(
  "lib/ignore.dart"
  "lib/ignore.txt"
)

LIB_FOLDER="lib"
OUTPUT_PREFIX="mcd_dart"
TARGET_SIZE_KB=1000  # Max size per output file (in KB)
REMOVE_COMMENTS=true  # Set to false to keep comments in output

# === Initialization ===
file_count=0
ignore_count=0
part=1

current_output=$(printf "%s-%03d.txt" "$OUTPUT_PREFIX" "$part")

# === Helpers ===
function should_ignore_file() {
  local filepath="$1"

  # Ignore based on path pattern or extension
  case "$filepath" in
    */generated/* | *.g.dart | lib/testing/* | lib/test/core/* | lib/autumn/*)
      echo "Ignoring: $filepath (pattern match)"
      return 0
      ;;
  esac

  # Ignore exact matches in IGNORE_FILES
  for ignore in "${IGNORE_FILES[@]}"; do
    if [[ "$filepath" == "$ignore" ]]; then
      echo "Ignoring: $filepath (in IGNORE_FILES)"
      return 0
    fi
  done

  # Ignore based on generated comment patterns
  if grep -q -E \
            -e "///This file is automatically generated\. DO NOT EDIT" \
            -e "/// GENERATED CODE - DO NOT MODIFY BY HAND" \
            -e "// File generated by FlutterFire CLI\." \
            -e "///This file is automatically generated\." \
            -e "/// FlutterGen" "$filepath"; then
    echo "Ignoring: $filepath (contains generated file comment)"
    return 0
  fi


  return 1  # File should not be ignored
}

# === Main Script ===

# Check if lib folder exists
if [ ! -d "$LIB_FOLDER" ]; then
  echo "Error: '$LIB_FOLDER' folder not found in current directory"
  exit 1
fi

# --- ADDED LINE: Delete existing output files ---
echo "Removing existing output files matching the pattern ${OUTPUT_PREFIX}-???.txt..."
rm -f "${OUTPUT_PREFIX}"-[0-9][0-9][0-9].txt
# -------------------------------------------------

echo "Combining .dart files from '$LIB_FOLDER' and subdirectories..."

# Read .dart files recursively
while IFS= read -r -d '' filepath; do
  if should_ignore_file "$filepath"; then
    ((ignore_count++))
    continue
  fi

  # Get the current size of the output file IF it exists
  current_size=0
  if [ -f "$current_output" ]; then
    current_size=$(wc -c < "$current_output")
  fi

  # Start new output file if current exceeds size threshold
  # Check size > 0 to ensure we don't switch on the very first file if it's large
  if [ "$current_size" -gt 0 ] && [ "$current_size" -gt $((TARGET_SIZE_KB * 1024)) ]; then
    part=$((part + 1))
    current_output=$(printf "%s-%03d.txt" "$OUTPUT_PREFIX" "$part")
    # Reset current_size as we are starting a new file
    current_size=0
  fi

  echo "Processing: $filepath -> $current_output"
  ((file_count++))

  # Use a temporary file for processing to avoid issues with large files/complex commands
  temp_processed=$(mktemp)
  echo "// File: $filepath" > "$temp_processed"
  if [ "$REMOVE_COMMENTS" = true ]; then
      # Remove block comments and inline comments, ignore empty lines
      # Improved comment removal using perl and sed more carefully
      perl -0777 -pe 's{/\*.*?\*/}{}gs' "$filepath" | sed -e '/^\s*\/\//d' -e '/^\s*$/d' >> "$temp_processed"
  else
      cat "$filepath" >> "$temp_processed"
  fi

  # Append the processed content to the current output file
  cat "$temp_processed" >> "$current_output"
  rm "$temp_processed" # Clean up temp file

done < <(find "$LIB_FOLDER" -type f -name "*.dart" -print0)

# === Summary ===
if [ $file_count -eq 0 ]; then
  echo "No .dart files were included after applying ignore rules."
  # Check if any output files were potentially created and left empty
  first_output_file=$(printf "%s-%03d.txt" "$OUTPUT_PREFIX" 1)
  if [ -f "$first_output_file" ] && [ ! -s "$first_output_file" ]; then
       rm "$first_output_file"
  fi
else
  # Check if the last created file is empty and remove it if so
  if [ -f "$current_output" ] && [ ! -s "$current_output" ]; then
     echo "Removing empty last output file: $current_output"
     rm "$current_output"
     # Adjust the part count if we removed the last file
     if [ $part -gt 1 ]; then
        part=$((part - 1 ))
     elif [ $file_count -gt 0 ]; then # If it was the only file and empty
        # This case shouldn't happen with the logic above, but for safety
        echo "Warning: The only output file was empty."
        part=0 # Indicate no valid output files
     fi

  fi

  if [ $part -gt 0 ]; then
     echo "Successfully combined $file_count files into $part output file(s) (up to ${OUTPUT_PREFIX}-$(printf "%03d" $part).txt)."
  else
     echo "Combined $file_count files, but the resulting output was empty after processing."
  fi
  echo "Ignored $ignore_count files."
fi


echo "Script completed."