// File: lib/core/detector.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:convert';
import 'dart:math' as math;
import 'package:image/image.dart';
import 'package:mcd_dart/mcd_dart.dart';
import 'package:path/path.dart' as path;
class MagicCardDetector {
  String? outputPath;
  List<ReferenceImage> referenceImages = [];
  List<TestImage> testImages = [];
  
  bool verbose = false;
  bool visual = false;
  
  double hashSeparationThr = 4.0;
  int thrLvl = 70;
  
  MagicCardDetector({this.outputPath});
  
  Future<void> exportReferenceData(String path) async {
    // Export the hash and card name data for future use
    List<Map<String, dynamic>> hashData = [];
    
    for (var image in referenceImages) {
      if (image.phash != null) {
        hashData.add({
          'name': image.name,
          'hash': image.phash!.hashValue.toString(),
        });
      }
    }
    
    final jsonData = jsonEncode(hashData);
    await File(path).writeAsString(jsonData);
  }
  
  Future<void> readPrehashReferenceData(String path) async {
    print('Reading prehashed data from $path');
    print('...');
    
    try {
      final content = await File(path).readAsString();
      final List<dynamic> data = jsonDecode(content);
      
      for (var item in data) {
        // Handle different hash formats (might be either string or integer from older format)
        BigInt hashValue;
        if (item['hash'] is String) {
          hashValue = BigInt.parse(item['hash']);
        } else {
          hashValue = BigInt.from(item['hash'] as int);
        }
        
        final hash = ImageHash(hashValue);
        referenceImages.add(
          ReferenceImage(item['name'], null, phash: hash)
        );
      }
      
      print('Done. Loaded ${referenceImages.length} reference cards from $path.');
    } catch (e) {
      print('Error reading reference data: $e');
      rethrow;
    }
  }
  
  /// Loads all available set hash files from the assets/set_hashes directory
  Future<void> loadAllSetHashes() async {
    print('Loading all available set hashes...');
    
    try {
      final hashFiles = Config.getAvailableSetHashes();
      
      if (hashFiles.isEmpty) {
        print('No hash files found in ${Config.getSetHashesDirectory()}');
        return;
      }
      
      int totalCards = 0;
      for (var file in hashFiles) {
        final initialCount = referenceImages.length;
        await readPrehashReferenceData(file.path);
        final newCards = referenceImages.length - initialCount;
        totalCards += newCards;
        print('Loaded $newCards cards from ${path.basename(file.path)}');
      }
      
      print('Total cards loaded from all set hashes: $totalCards');
    } catch (e) {
      print('Error loading set hashes: $e');
      rethrow;
    }
  }
  
  /// Reads and processes reference images from a directory (sequential version)
  Future<void> readAndAdjustReferenceImages(String directory) async {
    print('Reading images from $directory');
    print('...');
    
    final Directory dir = Directory(directory);
    final List<FileSystemEntity> entities = await dir.list().toList();
    final List<File> imageFiles = entities
        .whereType<File>()
        .where((File file) => file.path.toLowerCase().endsWith('.jpg'))
        .toList();
    
    for (File file in imageFiles) {
      final Uint8List bytes = await file.readAsBytes();
      final Image? img = decodeImage(bytes);
      
      if (img != null) {
        final String name = path.basename(file.path);
        referenceImages.add(ReferenceImage(name, img));
      }
    }
    
    print('Done. Loaded ${referenceImages.length} reference cards.');
  }
  
  /// Reads and processes reference images from a directory with parallel processing
  /// 
  /// [directory] - Directory containing reference card images
  /// [concurrency] - Number of images to process concurrently (default: 5)
  Future<void> readAndAdjustReferenceImagesParallel(String directory, {int concurrency = 5}) async {
    print('Reading images from $directory using parallel processing (concurrency: $concurrency)');
    print('...');
    
    final Stopwatch stopwatch = Stopwatch()..start();
    final Directory dir = Directory(directory);
    final List<FileSystemEntity> entities = await dir.list().toList();
    final List<File> imageFiles = entities
        .whereType<File>()
        .where((File file) => file.path.toLowerCase().endsWith('.jpg') || file.path.toLowerCase().endsWith('.jpeg'))
        .toList();
    
    int totalFiles = imageFiles.length;
    int processedFiles = 0;
    
    // Process files in batches to control memory usage
    for (int i = 0; i < totalFiles; i += concurrency) {
      final int end = i + concurrency < totalFiles ? i + concurrency : totalFiles;
      final batch = imageFiles.sublist(i, end);
      
      // Use Future.wait to process multiple images concurrently
      final results = await Future.wait(
        batch.map((File file) async {
          try {
            final Uint8List bytes = await file.readAsBytes();
            final Image? img = decodeImage(bytes);
            final String name = path.basename(file.path);
            
            if (img != null) {
              return ReferenceImage(name, img);
            }
          } catch (e) {
            print('Error processing file ${file.path}: $e');
          }
          return null;
        })
      );
      
      // Filter out nulls and add to reference images
      final validResults = results.where((item) => item != null).cast<ReferenceImage>();
      referenceImages.addAll(validResults);
      
      // Update progress
      processedFiles += batch.length;
      final progress = (processedFiles / totalFiles * 100).toStringAsFixed(1);
      final elapsed = stopwatch.elapsed;
      print('Progress: $progress% ($processedFiles/$totalFiles) - Elapsed: ${elapsed.inSeconds}s');
      
      // Short delay to allow memory cleanup
      await Future.delayed(const Duration(milliseconds: 10));
    }
    
    stopwatch.stop();
    print('Done. Loaded ${referenceImages.length} reference cards in ${stopwatch.elapsed.inSeconds} seconds.');
  }
  
  Future<void> readAndAdjustTestImages(String directory) async {
    print('Reading images from $directory');
    print('...');
    
    final int maxSize = 1000;
    
    final Directory dir = Directory(directory);
    final List<FileSystemEntity> entities = await dir.list().toList();
    final List<File> imageFiles = entities
        .whereType<File>()
        .where((File file) => file.path.toLowerCase().endsWith('.jpg') || file.path.toLowerCase().endsWith('.jpeg'))
        .toList();
    
    for (File file in imageFiles) {
      final Uint8List bytes = await file.readAsBytes();
      Image? img = decodeImage(bytes);
      
      if (img != null) {
        // Resize if needed
        if (math.min(img.width, img.height) > maxSize) {
          final double scalef = maxSize / math.min(img.width, img.height);
          img = copyResize(
            img,
            width: (img.width * scalef).toInt(),
            height: (img.height * scalef).toInt(),
            interpolation: Interpolation.average
          );
        }
        
        final String name = path.basename(file.path);
        testImages.add(TestImage(name, img));
      }
    }
    
    print('Done. Loaded ${testImages.length} test images.');
  }
  
  /// Reads and processes test images from a directory with parallel processing
  /// 
  /// [directory] - Directory containing test images
  /// [concurrency] - Number of images to process concurrently (default: 3)
  Future<void> readAndAdjustTestImagesParallel(String directory, {int concurrency = 3}) async {
    print('Reading test images from $directory using parallel processing (concurrency: $concurrency)');
    print('...');
    
    final Stopwatch stopwatch = Stopwatch()..start();
    final int maxSize = 1000;
    
    final Directory dir = Directory(directory);
    final List<FileSystemEntity> entities = await dir.list().toList();
    final List<File> imageFiles = entities
        .whereType<File>()
        .where((File file) => file.path.toLowerCase().endsWith('.jpg') || file.path.toLowerCase().endsWith('.jpeg'))
        .toList();
    
    int totalFiles = imageFiles.length;
    int processedFiles = 0;
    
    // Process files in batches to control memory usage (smaller batches for test images since they're typically larger)
    for (int i = 0; i < totalFiles; i += concurrency) {
      final int end = i + concurrency < totalFiles ? i + concurrency : totalFiles;
      final batch = imageFiles.sublist(i, end);
      
      // Use Future.wait to process multiple images concurrently
      final results = await Future.wait(
        batch.map((File file) async {
          try {
            final Uint8List bytes = await file.readAsBytes();
            Image? img = decodeImage(bytes);
            
            if (img != null) {
              // Resize if needed
              if (math.min(img.width, img.height) > maxSize) {
                final double scalef = maxSize / math.min(img.width, img.height);
                img = copyResize(
                  img,
                  width: (img.width * scalef).toInt(),
                  height: (img.height * scalef).toInt(),
                  interpolation: Interpolation.average
                );
              }
              
              final String name = path.basename(file.path);
              return TestImage(name, img);
            }
          } catch (e) {
            print('Error processing test file ${file.path}: $e');
          }
          return null;
        })
      );
      
      // Filter out nulls and add to test images
      final validResults = results.where((item) => item != null).cast<TestImage>();
      testImages.addAll(validResults);
      
      // Update progress
      processedFiles += batch.length;
      final progress = (processedFiles / totalFiles * 100).toStringAsFixed(1);
      final elapsed = stopwatch.elapsed;
      print('Progress: $progress% ($processedFiles/$totalFiles) - Elapsed: ${elapsed.inSeconds}s');
      
      // Short delay to allow memory cleanup
      await Future.delayed(const Duration(milliseconds: 50));
    }
    
    stopwatch.stop();
    print('Done. Loaded ${testImages.length} test images in ${stopwatch.elapsed.inSeconds} seconds.');
  }
  
  RecognitionResult recognizeSegment(Image imageSegment) {
    // Wrapper for different recognition algorithms
    return phashCompare(
      imageSegment, 
      referenceImages,
      hashSeparationThr: hashSeparationThr,
      verbose: verbose
    );
  }
  
  void recognizeCardsInImage(TestImage testImage, String contouringMode) {
    print('Segmenting card candidates out of the image...');
    print('Using $contouringMode algorithm.');
    
    testImage.candidateList.clear();
    segmentImage(testImage, contouringMode: contouringMode);
    
    print('Done. Found ${testImage.candidateList.length} candidates.');
    print('Recognizing candidates.');
    
    for (int iCand = 0; iCand < testImage.candidateList.length; iCand++) {
      CardCandidate candidate = testImage.candidateList[iCand];
      
      if (verbose) {
        print('${iCand + 1} / ${testImage.candidateList.length}');
      }
      
      // Easy fragment / duplicate detection
      bool isFragment = false;
      for (CardCandidate otherCandidate in testImage.candidateList) {
        if (otherCandidate.isRecognized && !otherCandidate.isFragment) {
          if (otherCandidate.contains(candidate)) {
            candidate.isFragment = true;
            isFragment = true;
            break;
          }
        }
      }
      
      if (!isFragment) {
        // Recognize the segment
        final RecognitionResult result = recognizeSegment(candidate.image);
        candidate.isRecognized = result.isRecognized;
        candidate.recognitionScore = result.recognitionScore;
        candidate.name = result.cardName;
      }
    }
    
    print('Done. Found ${testImage.returnRecognized().length} cards.');
    if (verbose) {
      for (CardCandidate card in testImage.returnRecognized()) {
        print('${card.name}; S = ${card.recognitionScore}');
      }
    }
    
    print('Removing duplicates...');
    // Final fragment detection
    testImage.markFragments();
    print('Done.');
  }
  
  Future<List<Uint8List>> processImage(Uint8List imageBytes, String imageName) async {
    print('\n--- Processing Image: $imageName ---');
    
    // Decode the image with memory optimization
    Image? image;
    try {
      // First try with default decoding
      image = decodeImage(imageBytes);
      
      // If the image is too large, resize it before processing
      if (image != null && (image.width > 3000 || image.height > 3000)) {
        print('Large image detected. Optimizing memory usage...');
        double scale = 2000 / (image.width > image.height ? image.width : image.height);
        image = copyResize(
          image,
          width: (image.width * scale).floor(),
          height: (image.height * scale).floor(),
          interpolation: Interpolation.average
        );
        // Force garbage collection to free memory after resize
        image.getBytes();
      }
    } catch (e) {
      print('Error during image decoding. Trying with optimization: $e');
      // Try again with a memory-optimized approach for large images
      try {
        // Use a different approach for large images
        // Create a downsampled version directly without using JpegDecoder
        // which has API compatibility issues
        final decoder = JpegDecoder();
        decoder.startDecode(imageBytes);
        
        // Get image info without fully decoding
        final info = decoder.info;
        if (info == null) {
          throw Exception('Could not get image info from JPEG');
        }
        
        int originalWidth = info.width;
        int originalHeight = info.height;
        
        // If the image is very large, create a downsampled version
        if (originalWidth > 3000 || originalHeight > 3000) {
          print('Creating downsampled version of large image...');
          double scale = 2000 / (originalWidth > originalHeight ? originalWidth : originalHeight);
          int targetWidth = (originalWidth * scale).floor();
          int targetHeight = (originalHeight * scale).floor();
          
          // Decode the full image first but with reduced quality
          // This is not ideal but safer than using the lower-level API
          Image? fullImage = decodeJpg(imageBytes);
          if (fullImage == null) {
            throw Exception('Failed to decode image with reduced quality');
          }
          
          // Now resize
          image = copyResize(
            fullImage,
            width: targetWidth,
            height: targetHeight,
            interpolation: Interpolation.average
          );
          
          // Release original image memory
          fullImage = Image(width: 1, height: 1);
        } else {
          // For smaller images, use standard decoding
          image = decodeJpg(imageBytes);
        }
      } catch (e) {
        print('Failed to decode image after optimization: $e');
        throw Exception('Failed to decode image: $e');
      }
    }
    
    if (image == null) {
      throw Exception('Failed to decode image');
    }
    
    // Create a temporary TestImage
    final TestImage testImage = TestImage(imageName, image);
    
    // Try different algorithms
    final List<String> algList = ['adaptive', 'rgb'];
    
    for (String alg in algList) {
      recognizeCardsInImage(testImage, alg);
      testImage.discardUnrecognizedCandidates();
      
      // Stop if we've found enough cards or exhausted search potential
      if (!testImage.mayContainMoreCards() || 
          testImage.returnRecognized().length > 5) {
        break;
      }
    }
    
    // Generate result images
    print('Generating result images...');
    
    // Original image bytes - using a more efficient compression setting
    final Uint8List originalBytes = encodeJpg(testImage.original, quality: 85);
    
    // Annotated image
    final Image annotatedImage = testImage.plotImageWithRecognized();
    final Uint8List annotatedBytes = encodeJpg(annotatedImage, quality: 85);
    
    print('Done.');
    
    // Return both images
    return [originalBytes, annotatedBytes];
  }
  
  Future<void> runRecognition([List<int>? imageIndices]) async {
    // The top-level image recognition method
    final List<int> indices = imageIndices ?? List<int>.generate(testImages.length, (int i) => i);
    
    for (int i in indices) {
      final TestImage testImage = testImages[i];
      print('Accessing image ${testImage.name}');
      
      if (visual) {
        print('Original image displayed');
      }
      
      final List<String> algList = ['adaptive', 'rgb'];
      
      for (String alg in algList) {
        recognizeCardsInImage(testImage, alg);
        testImage.discardUnrecognizedCandidates();
        
        if (!testImage.mayContainMoreCards() || 
            testImage.returnRecognized().length > 5) {
          break;
        }
      }
      
      print('Plotting and saving the results...');
      
      // Create annotated image
      final Image resultImage = testImage.plotImageWithRecognized();
      
      // Save to file if output path is provided
      if (outputPath != null) {
        final String fileName = testImage.name.contains('.jpg') 
            ? testImage.name.split('.jpg')[0] 
            : testImage.name;
        
        final String outFileName = path.join(
          outputPath!, 
          'MTG_card_recognition_results_$fileName.jpg'
        );
        
        final File outFile = File(outFileName);
        await outFile.writeAsBytes(encodeJpg(resultImage));
      }
      
      print('Done.');
      
      // Print recognized cards
      final List<CardCandidate> recognizedList = testImage.returnRecognized();
      print('Recognized cards (${recognizedList.length} cards):');
      for (CardCandidate card in recognizedList) {
        print('${card.name} - with score ${card.recognitionScore}');
      }
    }
    
    print('Recognition done.');
  }
}// File: lib/core/recognition.dart
import 'dart:math' as math;
import 'package:image/image.dart';
import '../models/image.dart';
import '../utils/image_hash.dart';
class RecognitionResult {
  final bool isRecognized;
  final double recognitionScore;
  final String cardName;
  
  RecognitionResult(this.isRecognized, this.recognitionScore, this.cardName);
}
List<double> phashDiff(List<ReferenceImage> referenceImages, ImageHash phashIm) {
  // Calculate the difference between the given hash and each reference image hash
  List<double> diff = List.filled(referenceImages.length, 0.0);
  
  for (int i = 0; i < referenceImages.length; i++) {
    // Calculate the hash distance
    if (referenceImages[i].phash != null) {
      diff[i] = phashIm.distanceTo(referenceImages[i].phash!);
    } else {
      diff[i] = double.infinity;
    }
  }
  
  return diff;
}
RecognitionResult phashCompare(
  Image imSeg, 
  List<ReferenceImage> referenceImages, 
  {double hashSeparationThr = 4.0, 
  bool verbose = false}
) {
  String cardName = 'unknown';
  bool isRecognized = false;
  double recognitionScore = 0.0;
  
  // Try different rotations
  List<double> rotations = [0.0, 90.0, 180.0, 270.0];
  
  List<double> d0Dist = List.filled(rotations.length, 0.0);
  
  // Memory optimization - process rotations one at a time
  for (int j = 0; j < rotations.length; j++) {
    // Apply rotation to the image
    Image rotatedImage;
    try {
      if (rotations[j].abs() > 1e-5) {
        rotatedImage = copyRotate(imSeg, angle: rotations[j].toInt());
      } else {
        rotatedImage = imSeg.clone();
      }
      
      // Calculate perceptual hash
      ImageHash phashIm = ImageHash.createPerceptualHash(rotatedImage);
      
      // Free rotated image memory as soon as possible
      rotatedImage = Image(width: 1, height: 1); // Small dummy image
      
      // Calculate differences with all reference images
      List<double> diffs = phashDiff(referenceImages, phashIm);
      
      // Calculate statistical distance
      double minDiff = double.infinity;
      for (double diff in diffs) {
        if (diff < minDiff) {
          minDiff = diff;
        }
      }
      
      // Create a list of differences excluding the minimum
      List<double> d0Filtered = [];
      for (double diff in diffs) {
        if (diff > minDiff) {
          d0Filtered.add(diff);
        }
      }
      
      // Calculate average and standard deviation
      double d0Ave = calculateAverage(d0Filtered);
      double d0Std = calculateStdDev(d0Filtered, d0Ave);
      
      // Calculate statistical distance
      d0Dist[j] = (d0Std > 0) ? (d0Ave - minDiff) / d0Std : 0;
      
      if (verbose) {
        print('Phash statistical distance (rotation ${rotations[j]}°): ${d0Dist[j]}');
      }
      
      // Check if this rotation gives a good recognition result
      if (d0Dist[j] > hashSeparationThr) {
        // Find index of minimum difference
        int minIndex = 0;
        double minVal = double.infinity;
        
        for (int i = 0; i < diffs.length; i++) {
          if (diffs[i] < minVal) {
            minVal = diffs[i];
            minIndex = i;
          }
        }
        
        // Get card name from reference image
        String fullName = referenceImages[minIndex].name;
        String candidateName = fullName.contains('.jpg') 
            ? fullName.split('.jpg')[0] 
            : fullName;
        
        double candidateScore = d0Dist[j] / hashSeparationThr;
        
        // If this is the best rotation so far, or first recognition
        if (!isRecognized || candidateScore > recognitionScore) {
          isRecognized = true;
          recognitionScore = candidateScore;
          cardName = candidateName;
        }
      }
      
      // Force garbage collection for especially large reference sets
      if (referenceImages.length > 500) {
        print('Large reference set detected. Optimizing memory during recognition...');
      }
    } catch (e) {
      print('Error processing rotation ${rotations[j]}°: $e');
      continue;
    }
  }
  
  // One more check to see if we need to adjust recognition threshold
  if (verbose && isRecognized) {
    print('Recognized as $cardName with score $recognitionScore');
  }
  
  return RecognitionResult(isRecognized, recognitionScore, cardName);
}
double calculateAverage(List<double> values) {
  if (values.isEmpty) return 0;
  return values.reduce((a, b) => a + b) / values.length;
}
double calculateStdDev(List<double> values, double average) {
  if (values.isEmpty) return 0;
  double sumSquaredDiff = values.fold(0, (sum, val) => sum + math.pow(val - average, 2));
  return math.sqrt(sumSquaredDiff / values.length);
}// File: lib/generate_hashes_from_scryfall.dart
import 'dart:io';
import 'package:args/args.dart';
import 'package:fast_log/fast_log.dart';
import 'package:path/path.dart' as path;
import 'package:mcd_dart/mcd_dart.dart';
void main(List<String> arguments) async {
  // Parse command-line arguments
  ArgParser parser = ArgParser()
    ..addOption('set', abbr: 's', help: 'Set code (e.g., "DSK", "LTR", "MOM")', mandatory: true)
    ..addOption('output', abbr: 'o', help: 'Path to output hash file', defaultsTo: Config.getDefaultReferenceHashPath())
    ..addOption('tempdir', abbr: 't', help: 'Temporary directory to store downloaded images', defaultsTo: 'temp_images')
    ..addFlag('keep-images', help: 'Keep downloaded images after hash generation', defaultsTo: false)
    ..addFlag('parallel', abbr: 'p', help: 'Use parallel processing for faster downloads and processing', defaultsTo: true)
    ..addOption('concurrency', help: 'Number of parallel operations to perform', defaultsTo: '4') 
    ..addFlag('help', abbr: 'h', help: 'Show this help message', defaultsTo: false);
  try {
    ArgResults results = parser.parse(arguments);
    if (results['help'] as bool) {
      printUsage(parser);
      exit(0);
    }
    // Get parameters
    String setCode = results['set'] as String;
    String outputFile = results['output'] as String;
    String tempDir = results['tempdir'] as String;
    bool keepImages = results['keep-images'] as bool;
    bool useParallel = results['parallel'] as bool;
    int concurrency = int.tryParse(results['concurrency'] as String) ?? 4;
    
    // Always use verbose output
    bool verbose = true;
    
    if (verbose) {
      info('Mode: ${useParallel ? "Parallel" : "Sequential"}');
      if (useParallel) {
        info('Concurrency level: $concurrency');
      }
    }
    
    // Always modify the output path to include the set name
    final hashesDir = Config.getSetHashesDirectory();
    outputFile = path.join(hashesDir, '${setCode.toLowerCase()}_reference_phash.dat');
    info('Using output file: $outputFile');
    // Create a temporary directory for downloaded images
    final tempDirectory = Directory(tempDir);
    if (await tempDirectory.exists()) {
      info('Clearing temporary directory: ${tempDirectory.path}');
      await tempDirectory.delete(recursive: true);
    }
    await tempDirectory.create(recursive: true);
    info('Created temporary directory: ${tempDirectory.path}');
    // Initialize the Scryfall client
    final scryfallClient = ScryfallClient(verbose: verbose);
    info('Initialized Scryfall client');
    try {
      // Download images for the specified set
      info('Downloading images for set: $setCode');
      List<String> downloadedFiles;
      
      // Use parallel or sequential download based on user choice
      if (useParallel) {
        downloadedFiles = await scryfallClient.downloadSetImagesParallel(
          setCode, 
          tempDirectory.path,
          size: ImageSize.large,
          concurrency: concurrency
        );
      } else {
        downloadedFiles = await scryfallClient.downloadSetImages(
          setCode, 
          tempDirectory.path,
          size: ImageSize.large
        );
      }
      
      info('Downloaded ${downloadedFiles.length} images for set $setCode');
      if (downloadedFiles.isEmpty) {
        error('No images were downloaded. Please check your set code.');
        exit(1);
      }
      // Initialize the card detector
      MagicCardDetector detector = MagicCardDetector();
      detector.verbose = verbose;
      // Process the downloaded images
      info('Processing downloaded images...');
      
      // Use parallel or sequential processing based on user choice
      if (useParallel) {
        await detector.readAndAdjustReferenceImagesParallel(
          tempDirectory.path,
          concurrency: concurrency
        );
      } else {
        await detector.readAndAdjustReferenceImages(tempDirectory.path);
      }
      
      info('Processed ${detector.referenceImages.length} reference images');
      // Export hash data
      info('Exporting reference hash data to $outputFile');
      try {
        // Create output directory if it doesn't exist
        final outputDir = Directory(path.dirname(outputFile));
        if (!await outputDir.exists()) {
          await outputDir.create(recursive: true);
          info('Created output directory: ${outputDir.path}');
        }
        
        await detector.exportReferenceData(outputFile);
        info('Hash database successfully exported with ${detector.referenceImages.length} cards');
      } catch (e) {
        error('Error exporting hash data: $e');
        exit(1);
      }
      // Clean up downloaded images if not keeping them
      if (!keepImages) {
        info('Cleaning up temporary images...');
        await tempDirectory.delete(recursive: true);
        info('Temporary directory removed');
      } else {
        info('Keeping downloaded images in: ${tempDirectory.path}');
      }
      // Clean up resources
      scryfallClient.close();
      success('Done! Hash database created successfully for set $setCode');
    } catch (e) {
      error('Error: $e');
      // Clean up on error
      scryfallClient.close();
      if (!keepImages && await tempDirectory.exists()) {
        await tempDirectory.delete(recursive: true);
      }
      exit(1);
    }
  } catch (e) {
    error('Error: $e');
    printUsage(parser);
    exit(1);
  }
}
void printUsage(ArgParser parser) {
  info('Magic Card Detector - Hash Generator (Scryfall)');
  info('Usage: generate_hashes_from_scryfall --set=<SET_CODE> [options]');
  info(parser.usage);
}// File: lib/utils/image_hash.dart
import 'package:image/image.dart';
class ImageHash {
  /// The internal hash value
  final BigInt hashValue;
  /// Creates a hash with the given value
  const ImageHash(this.hashValue);
  /// Creates a perceptual hash from an image
  factory ImageHash.createPerceptualHash(Image image) {
    // Use a more memory-efficient approach for processing, especially for large images
    // First, resize to a reasonable size to avoid memory issues during processing
    final int maxDimension = 1000;
    Image processImage = image;
    if (image.width > maxDimension || image.height > maxDimension) {
      double scale = maxDimension / (image.width > image.height ? image.width : image.height);
      processImage = copyResize(
        image, 
        width: (image.width * scale).floor(),
        height: (image.height * scale).floor(),
        interpolation: Interpolation.average
      );
    }
    
    // Now resize to the target size for the hash algorithm (match Python's 32x32)
    final resizedImage = copyResize(processImage, width: 32, height: 32, interpolation: Interpolation.average);
    
    // Convert to grayscale
    final grayImage = grayscale(resizedImage);
    
    // Calculate perceptual hash
    BigInt hash = _calculatePerceptualHash(grayImage);
    
    return ImageHash(hash);
  }
  /// Computes the Hamming distance between this hash and another hash
  double distanceTo(ImageHash other) {
    return _hammingDistance(hashValue, other.hashValue);
  }
  /// Hamming distance between two BigInts counts the number of bit positions that differ
  double _hammingDistance(BigInt a, BigInt b) {
    BigInt xor = a ^ b;
    int distance = 0;
    
    // Count the number of set bits (1s) in xor
    while (xor != BigInt.zero) {
      if (xor & BigInt.one == BigInt.one) {
        distance++;
      }
      xor = xor >> 1;
    }
    
    return distance.toDouble();
  }
  @override
  String toString() => 'ImageHash($hashValue)';
}
BigInt _calculatePerceptualHash(Image image) {
  const int hashSize = 32; // Match Python's hash_size=32
  
  // Ensure image is grayscale and properly sized
  Image img = image;
  if (img.width != hashSize || img.height != hashSize) {
    img = copyResize(img, width: hashSize, height: hashSize, interpolation: Interpolation.average);
  }
  
  // Step 1: Compute the DCT (Discrete Cosine Transform) approximation with mean values
  // For simplicity and memory efficiency, we'll use a mean-based approach
  int sum = 0;
  for (int y = 0; y < hashSize; y++) {
    for (int x = 0; x < hashSize; x++) {
      sum += getBrightness(img.getPixel(x, y));
    }
  }
  int average = sum ~/ (hashSize * hashSize);
  
  // Step 2: Generate the hash bits based on whether pixels are above or below average
  // Use BigInt to handle the larger size (1024 bits for 32x32)
  BigInt hash = BigInt.zero;
  for (int y = 0; y < hashSize; y++) {
    for (int x = 0; x < hashSize; x++) {
      if (getBrightness(img.getPixel(x, y)) > average) {
        // Set the corresponding bit to 1
        hash = hash | (BigInt.one << (y * hashSize + x));
      }
    }
  }
  
  return hash;
}
int getBrightness(Pixel pixel) {
  int r = pixel.r.toInt();
  int g = pixel.g.toInt();
  int b = pixel.b.toInt();
  return ((r + g + b) / 3).round();
}// File: lib/utils/scryfall_client.dart
import 'dart:io';
import 'dart:async';
import 'dart:typed_data';
import 'dart:convert';
import 'package:fast_log/fast_log.dart';
import 'package:path/path.dart' as path;
import 'package:scryfall_api/scryfall_api.dart';
import 'package:http/http.dart' as http;
class ScryfallClient {
  final ScryfallApiClient _client;
  final bool verbose;
  /// Directory where temporary downloaded images are stored
  final String? cacheDir;
  ScryfallClient({
    this.verbose = false,
    this.cacheDir,
  }) : _client = ScryfallApiClient();
  /// Close the client and cleanup resources
  void close() {
    _client.close();
  }
  /// Get all cards from a specific set by set code
  Future<List<MtgCard>> getCardsBySetCode(String setCode) async {
    if (verbose) {
      info('Fetching cards for set: $setCode');
    }
    final List<MtgCard> cards = <MtgCard>[];
    
    try {
      // Get the first page of results
      final PaginableList<MtgCard> searchResult = await _client.searchCards('set:$setCode');
      cards.addAll(searchResult.data);
      
      // Get all subsequent pages if any
      PaginableList<MtgCard>? currentPage = searchResult;
      while (currentPage?.hasMore == true) {
        // Handle pagination manually since getNextPage isn't available
        final Uri? nextPageUri = currentPage!.nextPage;
        if (nextPageUri == null) break;
        
        final http.Response response = await http.get(nextPageUri);
        if (response.statusCode != 200) {
          throw Exception('Failed to fetch next page: ${response.statusCode}');
        }
        
        // Parse the response body as JSON map
        final Map<String, dynamic> jsonMap = json.decode(response.body) as Map<String, dynamic>;
        final PaginableList<MtgCard> nextPage = PaginableList<MtgCard>.fromJson(
          jsonMap, 
          (dynamic json) => MtgCard.fromJson(json as Map<String, dynamic>)
        );
        
        cards.addAll(nextPage.data);
        currentPage = nextPage;
      }
      
      if (verbose) {
        success('Found ${cards.length} cards in set $setCode');
      }
      
      return cards;
    } catch (e) {
      error('Error fetching cards for set $setCode: $e');
      rethrow;
    }
  }
  /// Get image URL for a card, handling double-faced cards
  String? getCardImageUrl(MtgCard card, {ImageSize size = ImageSize.large}) {
    // For normal cards
    if (card.imageUris != null) {
      return _getImageUrlBySize(card.imageUris!, size);
    }
    // For double-faced cards, return front face
    else if (card.cardFaces != null && card.cardFaces!.isNotEmpty) {
      return _getImageUrlBySize(card.cardFaces!.first.imageUris!, size);
    }
    return null;
  }
  /// Helper to get image URL based on requested size
  String? _getImageUrlBySize(ImageUris uris, ImageSize size) {
    switch (size) {
      case ImageSize.small:
        return uris.small.toString();
      case ImageSize.normal:
        return uris.normal.toString();
      case ImageSize.large:
        return uris.large.toString();
      case ImageSize.png:
        return uris.png.toString();
      case ImageSize.artCrop:
        return uris.artCrop.toString();
      case ImageSize.borderCrop:
        return uris.borderCrop.toString();
    }
  }
  /// Download a card image by set code and collector number
  Future<Uint8List> downloadCardImage(String setCode, String collectorNumber,
      {ImageSize size = ImageSize.large}) async {
    try {
      if (verbose) {
        info('Downloading image for card: $setCode #$collectorNumber');
      }
      final Uint8List imageBytes = await _client.getCardBySetCodeAndCollectorNumberAsImage(
        setCode,
        collectorNumber,
        imageVersion: _getApiImageVersion(size),
      );
      if (verbose) {
        success('Downloaded image: $setCode #$collectorNumber (${imageBytes.length} bytes)');
      }
      return imageBytes;
    } catch (e) {
      error('Error downloading image for card $setCode #$collectorNumber: $e');
      rethrow;
    }
  }
  /// Download a card image from a URL
  Future<Uint8List> downloadImageFromUrl(String url) async {
    try {
      if (verbose) {
        info('Downloading image from URL: $url');
      }
      final http.Response response = await http.get(Uri.parse(url));
      
      if (response.statusCode != 200) {
        throw Exception('Failed to download image: ${response.statusCode}');
      }
      
      if (verbose) {
        success('Downloaded image: ${response.bodyBytes.length} bytes');
      }
      return response.bodyBytes;
    } catch (e) {
      error('Error downloading image from URL: $e');
      rethrow;
    }
  }
  /// Download all card images for a set and save to a directory (sequential version)
  Future<List<String>> downloadSetImages(String setCode, String outputDir,
      {ImageSize size = ImageSize.large}) async {
    final List<MtgCard> cards = await getCardsBySetCode(setCode);
    final List<String> downloadedFiles = <String>[];
    
    // Create output directory if it doesn't exist
    final Directory directory = Directory(outputDir);
    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }
    
    for (final MtgCard card in cards) {
      try {
        // Skip cards without images (like tokens or special card entries)
        String? imageUrl = getCardImageUrl(card, size: size);
        if (imageUrl == null) {
          warn('No image available for card: ${card.name}');
          continue;
        }
        
        // Generate a safe filename
        final String filename = '${card.name.replaceAll(RegExp(r'[^\w\s]'), '_')}_${card.collectorNumber}.jpg';
        final String filePath = path.join(outputDir, filename);
        
        // Download the image
        final Uint8List imageBytes = await downloadImageFromUrl(imageUrl);
        
        // Save to file
        await File(filePath).writeAsBytes(imageBytes);
        downloadedFiles.add(filePath);
        
        if (verbose) {
          info('Saved: $filename');
        }
        
        // Be nice to the Scryfall API - add a small delay between requests
        await Future.delayed(const Duration(milliseconds: 100));
      } catch (e) {
        warn('Error downloading card ${card.name}: $e');
      }
    }
    
    return downloadedFiles;
  }
  
  /// Download all card images for a set and save to a directory with parallel processing
  /// 
  /// [setCode] - The set code (e.g. "LTR", "MOM")
  /// [outputDir] - Directory to save downloaded images
  /// [size] - Image size to download
  /// [concurrency] - Number of parallel downloads (default: 4)
  Future<List<String>> downloadSetImagesParallel(String setCode, String outputDir,
      {ImageSize size = ImageSize.large, int concurrency = 4}) async {
    final Stopwatch stopwatch = Stopwatch()..start();
    final List<MtgCard> cards = await getCardsBySetCode(setCode);
    
    if (verbose) {
      info('Starting parallel download of ${cards.length} images from set $setCode (concurrency: $concurrency)');
    }
    
    // Create output directory if it doesn't exist
    final Directory directory = Directory(outputDir);
    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }
    
    final List<String> downloadedFiles = <String>[];
    int totalCards = cards.length;
    int processedCards = 0;
    
    // Process cards in batches to control parallel requests
    for (int i = 0; i < totalCards; i += concurrency) {
      final int end = i + concurrency < totalCards ? i + concurrency : totalCards;
      final batch = cards.sublist(i, end);
      
      // Start concurrent downloads
      final results = await Future.wait(
        batch.map((MtgCard card) async {
          try {
            // Skip cards without images
            String? imageUrl = getCardImageUrl(card, size: size);
            if (imageUrl == null) {
              if (verbose) {
                warn('No image available for card: ${card.name}');
              }
              return null;
            }
            
            // Generate a safe filename
            final String filename = '${card.name.replaceAll(RegExp(r'[^\w\s]'), '_')}_${card.collectorNumber}.jpg';
            final String filePath = path.join(outputDir, filename);
            
            // Download the image
            final Uint8List imageBytes = await downloadImageFromUrl(imageUrl);
            
            // Save to file
            await File(filePath).writeAsBytes(imageBytes);
            
            if (verbose) {
              info('Downloaded: ${card.name}');
            }
            
            return filePath;
          } catch (e) {
            warn('Error downloading card ${card.name}: $e');
            return null;
          }
        }),
        eagerError: false // Continue processing other downloads even if some fail
      );
      
      // Filter out nulls and add to downloaded files list
      final validResults = results.where((path) => path != null).cast<String>();
      downloadedFiles.addAll(validResults);
      
      // Update progress
      processedCards += batch.length;
      final progress = (processedCards / totalCards * 100).toStringAsFixed(1);
      final elapsed = stopwatch.elapsed;
      
      if (verbose) {
        info('Progress: $progress% ($processedCards/$totalCards) - Downloaded: ${downloadedFiles.length} images - Elapsed: ${elapsed.inSeconds}s');
      }
      
      // Add a small delay between batches to be nice to Scryfall API
      await Future.delayed(const Duration(milliseconds: 200));
    }
    
    stopwatch.stop();
    if (verbose) {
      success('Downloaded ${downloadedFiles.length} images in ${stopwatch.elapsed.inSeconds} seconds');
    }
    
    return downloadedFiles;
  }
  /// Convert our ImageSize enum to Scryfall API's ImageVersion
  ImageVersion _getApiImageVersion(ImageSize size) {
    switch (size) {
      case ImageSize.small:
        return ImageVersion.small;
      case ImageSize.normal:
        return ImageVersion.normal;
      case ImageSize.large:
        return ImageVersion.large;
      case ImageSize.png:
        return ImageVersion.png;
      case ImageSize.artCrop:
        return ImageVersion.artCrop;
      case ImageSize.borderCrop:
        return ImageVersion.borderCrop;
    }
  }
}
enum ImageSize {
  small,
  normal,
  large,
  png, // High quality
  artCrop,
  borderCrop,
}// File: lib/utils/config.dart
import 'dart:io';
import 'package:path/path.dart' as path;
class Config {
  // Reference image settings
  static const String defaultHashesDirectory = 'assets/set_hashes';
  static const String defaultReferenceHashFile = 'default_reference_phash.dat';
  
  // Processing settings
  static const double defaultHashSeparationThreshold = 4.0;
  static const int defaultThresholdLevel = 70;
  static const int maxImageSize = 1000;
  
  // Image file extensions
  static const List<String> supportedImageExtensions = ['.jpg', '.jpeg', '.png'];
  
  // Output path for results
  static const String defaultResultsDirectory = 'assets/out';
  
  /// Get the absolute path to the set hashes directory
  static String getSetHashesDirectory() {
    // Get the script directory
    final String scriptDir = Directory.current.path;
    return path.join(scriptDir, defaultHashesDirectory);
  }
  
  /// Get all available set hash files
  static List<File> getAvailableSetHashes() {
    final String hashesDir = getSetHashesDirectory();
    
    try {
      final Directory hashesDirectory = Directory(hashesDir);
      if (!hashesDirectory.existsSync()) {
        print('Warning: Set hashes directory does not exist: $hashesDir');
        return [];
      }
      
      final List<File> files = hashesDirectory
          .listSync()
          .whereType<File>()
          .where((File file) => file.path.endsWith('.dat'))
          .toList();
      
      return files;
    } catch (e) {
      print('Error reading set hashes directory: $e');
      return [];
    }
  }
  
  /// Get the default reference hash file path
  static String getDefaultReferenceHashPath() {
    return path.join(getSetHashesDirectory(), defaultReferenceHashFile);
  }
}// File: lib/models/image.dart
import 'dart:math' as math;
import 'package:image/image.dart';
import 'package:mcd_dart/image/processing.dart';
import 'card.dart';
import '../geometry/polygons.dart';
import '../utils/image_hash.dart';
class ReferenceImage {
  final String name;
  final Image? original;
  Image? adjusted;
  ImageHash? phash;
  ReferenceImage(this.name, this.original, {this.phash}) {
    if (original != null) {
      histogramAdjust();
      calculatePhash();
    }
  }
  void calculatePhash() {
    if (adjusted != null) {
      // Create a copy of the image to manipulate
      Image imgForHash = adjusted!.clone();
      
      // Convert to proper format for hashing
      phash = ImageHash.createPerceptualHash(imgForHash);
    }
  }
  void histogramAdjust() {
    if (original != null) {
      // Convert to LAB-like space for processing
      // This is an approximation as Dart doesn't have direct LAB conversion
      adjusted = adjustContrast(original!);
    }
  }
}
class TestImage {
  final String name;
  final Image original;
  Image? adjusted;
  ImageHash? phash;
  bool visual = false;
  List<CardCandidate> candidateList = [];
  TestImage(this.name, this.original) {
    histogramAdjust();
  }
  void histogramAdjust() {
    // Apply contrast enhancement as a substitute for CLAHE
    adjusted = adjustContrast(original);
  }
  void markFragments() {
    // Find duplicates and mark one as fragment
    for (int i = 0; i < candidateList.length; i++) {
      for (int j = 0; j < candidateList.length; j++) {
        CardCandidate candidate = candidateList[i];
        CardCandidate otherCandidate = candidateList[j];
        
        if (candidate.isFragment || otherCandidate.isFragment) {
          continue;
        }
        
        if ((candidate.isRecognized || otherCandidate.isRecognized) && 
            i != j) {
          // Calculate intersection area
          Polygon? intersection = candidate.boundingQuad.intersection(otherCandidate.boundingQuad);
          if (intersection == null) continue;
          
          double iArea = intersection.area();
          double minArea = math.min(candidate.boundingQuad.area(), otherCandidate.boundingQuad.area());
          
          if (iArea > 0.5 * minArea) {
            if (candidate.isRecognized && otherCandidate.isRecognized) {
              if (candidate.recognitionScore < otherCandidate.recognitionScore) {
                candidate.isFragment = true;
              } else {
                otherCandidate.isFragment = true;
              }
            } else {
              if (candidate.isRecognized) {
                otherCandidate.isFragment = true;
              } else {
                candidate.isFragment = true;
              }
            }
          }
        }
      }
    }
  }
  Image plotImageWithRecognized() {
    // Create a copy of the original for drawing
    Image result = original.clone();
    
    // Draw bounding quadrilateral and labels for each recognized card
    for (CardCandidate candidate in candidateList) {
      if (!candidate.isFragment) {
        // Draw the bounding quadrilateral
        drawPolygon(result, candidate.boundingQuad, colorGreen);
        
        // Add a label with the card name
        Point2D center = candidate.boundingQuad.centroid();
        drawText(
          result,
          candidate.name,
          center.x.round(),
          center.y.round(),
          candidate.isRecognized ? colorWhite : colorRed,
        );
      }
    }
    
    return result;
  }
  List<CardCandidate> returnRecognized() {
    return candidateList
        .where((CardCandidate candidate) => candidate.isRecognized && !candidate.isFragment)
        .toList();
  }
  void discardUnrecognizedCandidates() {
    List<CardCandidate> recognized = returnRecognized();
    candidateList.clear();
    candidateList.addAll(recognized);
  }
  bool mayContainMoreCards() {
    List<CardCandidate> recognized = returnRecognized();
    
    if (recognized.isEmpty) {
      return true;
    }
    
    double totalArea = 0.0;
    double minArea = 1.0;
    
    for (CardCandidate card in recognized) {
      totalArea += card.imageAreaFraction;
      if (card.imageAreaFraction < minArea) {
        minArea = card.imageAreaFraction;
      }
    }
    
    return totalArea + 1.5 * minArea < 1.0;
  }
}
final colorGreen = ColorRgb8(0, 255, 0);
final colorWhite = ColorRgb8(255, 255, 255);
final colorRed = ColorRgb8(255, 0, 0);
void drawPolygon(Image image, Polygon polygon, ColorRgb8 color) {
  List<Point2D> vertices = polygon.vertices;
  for (int i = 0; i < vertices.length; i++) {
    Point2D start = vertices[i];
    Point2D end = vertices[(i + 1) % vertices.length];
    
    // Use the image package's drawLine function
    drawLine(
      image,
      x1: start.x.round(),
      y1: start.y.round(),
      x2: end.x.round(),
      y2: end.y.round(),
      color: color,
    );
  }
}
void drawText(Image image, String text, int x, int y, ColorRgb8 color) {
  int fontSize = 12;  // Approximate font size
  int textWidth = text.length * fontSize ~/ 2;
  
  // Draw a simple rectangle background
  ColorRgb8 bgColor = color == colorWhite 
      ? ColorRgb8(0, 0, 0) 
      : ColorRgb8(255, 255, 255);
  
  // Draw the background rectangle
  fillRect(
    image,
    x1: x - textWidth ~/ 2,
    y1: y - fontSize ~/ 2,
    x2: x + textWidth ~/ 2,
    y2: y + fontSize ~/ 2,
    color: bgColor,
  );
  
  // Draw the text in a simple way
  // Skip using font for now, since we'll just use simple rectangles
  
  // Center the text
  int startX = x - textWidth ~/ 2;
  int startY = y - fontSize ~/ 2;
  
  for (int i = 0; i < text.length; i++) {
    // Draw a simple colored rectangle for each character (simplified approach)
    fillRect(
      image,
      x1: startX + i * (fontSize ~/ 2),
      y1: startY,
      x2: startX + (i + 1) * (fontSize ~/ 2),
      y2: startY + fontSize,
      color: color,
    );
  }
}// File: lib/models/card.dart
import 'package:image/image.dart';
import '../geometry/polygons.dart';
class CardCandidate {
  final Image image;
  final Polygon boundingQuad;
  final double imageAreaFraction;
  bool isRecognized;
  double recognitionScore;
  bool isFragment;
  String name;
  CardCandidate(
    this.image,
    this.boundingQuad,
    this.imageAreaFraction, {
    this.isRecognized = false,
    this.recognitionScore = 0.0,
    this.isFragment = false,
    this.name = 'unknown',
  });
  bool contains(CardCandidate other) {
    return boundingQuad.contains(other.boundingQuad) && name == other.name;
  }
}// File: lib/image/processing.dart
import 'package:image/image.dart';
import 'package:mcd_dart/mcd_dart.dart';
import 'dart:math' as math;
List<List<List<int>>> contourImageGray(Image fullImage, {String thresholding = 'adaptive'}) {
  // Convert to grayscale
  Image gray = grayscale(fullImage);
  
  // Apply thresholding
  Image thresh;
  
  if (thresholding == 'adaptive') {
    // Approximate adaptive thresholding
    int filterSize = 1 + 2 * (math.min(fullImage.width, fullImage.height) ~/ 20);
    thresh = adaptiveThreshold(gray, filterSize, 10);
  } else {
    // Simple thresholding
    thresh = threshold(gray, 70);
  }
  
  // Find contours
  return findContours(thresh);
}
List<List<List<int>>> contourImageRgb(Image fullImage) {
  // Split into RGB channels
  List<Image> channels = extractChannels(fullImage);
  
  // Apply histogram equalization and thresholding to each channel
  List<Image> thresholds = [];
  
  for (Image channelImage in channels) {
    
    // Apply clahe-like enhancement
    channelImage = adjustContrast(channelImage); 
    
    // Apply thresholding
    thresholds.add(threshold(channelImage, 110));
  }
  
  // Find contours in each threshold
  List<List<List<int>>> allContours = [];
  
  for (Image threshold in thresholds) {
    allContours.addAll(findContours(threshold));
  }
  
  return allContours;
}
List<List<List<int>>> contourImage(Image fullImage, {String mode = 'gray'}) {
  List<List<List<int>>> contours;
  
  if (mode == 'gray') {
    contours = contourImageGray(fullImage, thresholding: 'simple');
  } else if (mode == 'adaptive') {
    contours = contourImageGray(fullImage, thresholding: 'adaptive');
  } else if (mode == 'rgb') {
    contours = contourImageRgb(fullImage);
  } else if (mode == 'all') {
    contours = [
      ...contourImageGray(fullImage, thresholding: 'simple'),
      ...contourImageGray(fullImage, thresholding: 'adaptive'),
      ...contourImageRgb(fullImage)
    ];
  } else {
    throw ArgumentError('Unknown segmentation mode: $mode');
  }
  
  // Sort contours by area (largest first)
  contours.sort((List<List<int>> a, List<List<int>> b) => calculateContourArea(b).compareTo(calculateContourArea(a)));
  
  return contours;
}
void segmentImage(
  TestImage testImage, {
  String contouringMode = 'gray',
}) {
  // Create a copy of the adjusted image with memory optimization
  Image fullImage;
  try {
    // Memory optimization for large images before segmentation
    if (testImage.adjusted!.width > 2000 || testImage.adjusted!.height > 2000) {
      print('Large image detected. Optimizing memory for segmentation...');
      double scale = 2000 / (testImage.adjusted!.width > testImage.adjusted!.height 
                            ? testImage.adjusted!.width 
                            : testImage.adjusted!.height);
      fullImage = copyResize(
        testImage.adjusted!,
        width: (testImage.adjusted!.width * scale).floor(),
        height: (testImage.adjusted!.height * scale).floor(),
        interpolation: Interpolation.average
      );
    } else {
      fullImage = testImage.adjusted!.clone();
    }
  } catch (e) {
    print('Error preparing image for segmentation: $e');
    // Fallback to the original image but at lower resolution
    double scale = 1000 / (testImage.adjusted!.width > testImage.adjusted!.height 
                          ? testImage.adjusted!.width 
                          : testImage.adjusted!.height);
    fullImage = copyResize(
      testImage.adjusted!,
      width: (testImage.adjusted!.width * scale).floor(),
      height: (testImage.adjusted!.height * scale).floor(),
      interpolation: Interpolation.average
    );
    print('Using fallback lower resolution for segmentation.');
  }
  
  double imageArea = fullImage.width * fullImage.height.toDouble();
  double maxSegmentArea = 0.01; // Initial value for largest card area
  
  // Get contours using the specified mode - limit number of contours to avoid memory issues
  List<List<List<int>>> contours = contourImage(fullImage, mode: contouringMode);
  
  // Limit number of contours to process to avoid memory issues
  int maxContours = 50; // Reasonable limit
  if (contours.length > maxContours) {
    print('Limiting contour processing to $maxContours contours to conserve memory.');
    contours = contours.sublist(0, maxContours);
  }
  
  // Process each contour to find card candidates
  int processedContours = 0;
  for (List<List<int>> cardContour in contours) {
    try {
      // Periodically trigger garbage collection for large contour sets
      processedContours++;
      if (processedContours % 10 == 0) {
        // Force a pause to allow garbage collection
        print('Processed $processedContours contours...');
      }
      
      CardContourResult result = characterizeCardContour(
        cardContour,
        maxSegmentArea * imageArea,
        imageArea
      );
      
      if (!result.continueSegmentation) {
        break;
      }
      
      if (result.isCardCandidate && result.boundingPoly != null) {
        if (maxSegmentArea < 0.1) {
          maxSegmentArea = result.boundingPoly!.area() / imageArea;
        }
        
        // Apply perspective transform
        Polygon scaledPoly = scalePolygon(
          result.boundingPoly!, 
          result.cropFactor, 
          result.cropFactor
        );
        
        // Try to transform with memory optimization
        Image warped;
        try {
          warped = fourPointTransform(fullImage, scaledPoly);
        } catch (e) {
          print('Error in perspective transform: $e');
          // Try with a smaller region to avoid memory issues
          double scale = 0.9; // Slight reduction
          Polygon smallerPoly = scalePolygon(scaledPoly, scale, scale);
          warped = fourPointTransform(fullImage, smallerPoly);
        }
        
        // Add to candidate list
        testImage.candidateList.add(
          CardCandidate(
            warped,
            result.boundingPoly!,
            result.boundingPoly!.area() / imageArea
          )
        );
        
        // Limit to a reasonable number of candidates to avoid memory issues
        if (testImage.candidateList.length >= 15) {
          print('Reached maximum number of candidates (15). Stopping segmentation.');
          break;
        }
      }
    } catch (e) {
      print('Error processing contour: $e');
      continue;
    }
  }
}
double calculateContourArea(List<List<int>> contour) {
  // Calculate the area of a contour using the Shoelace formula
  double area = 0.0;
  int n = contour.length;
  
  for (int i = 0; i < n; i++) {
    int j = (i + 1) % n;
    area += contour[i][0] * contour[j][1];
    area -= contour[j][0] * contour[i][1];
  }
  
  return (area.abs() / 2.0);
}
List<List<List<int>>> findContours(Image binaryImage) {
  // A simplified contour detection algorithm
  // For real applications, a more sophisticated algorithm would be needed
  
  // Create a copy for flood-fill operations
  Image labelImage = Image(width: binaryImage.width, height: binaryImage.height);
  
  int currentLabel = 1;
  List<List<List<int>>> contours = [];
  
  // Find connected components
  for (int y = 1; y < binaryImage.height - 1; y++) {
    for (int x = 1; x < binaryImage.width - 1; x++) {
      if (getBrightness(binaryImage.getPixel(x, y)) > 127 &&
          getBrightness(labelImage.getPixel(x, y)) == 0) {
        // New component found, assign a label
        List<List<int>> contour = [];
        floodFill(binaryImage, labelImage, x, y, currentLabel, contour);
        
        // Only add contours with enough points
        if (contour.length >= 5) {
          contours.add(contour);
          currentLabel++;
        }
      }
    }
  }
  
  // Approximate contours (reduce number of points)
  List<List<List<int>>> approximatedContours = [];
  for (List<List<int>> contour in contours) {
    approximatedContours.add(approximateContour(contour));
  }
  
  return approximatedContours;
}
void floodFill(Image source, Image labelImage, int x, int y, int label, List<List<int>> contour) {
  // Simple 4-connected flood fill
  List<List<int>> stack = [[x, y]];
  bool isContourPoint = false;
  
  while (stack.isNotEmpty) {
    List<int> point = stack.removeLast();
    int px = point[0];
    int py = point[1];
    
    // Check if already labeled or not a foreground pixel
    if (px < 0 || py < 0 || px >= source.width || py >= source.height ||
        getBrightness(labelImage.getPixel(px, py)) != 0 ||
        getBrightness(source.getPixel(px, py)) <= 127) {
      continue;
    }
    
    // Label this pixel
    labelImage.setPixel(px, py, getColor(label, label, label, 255));
    
    // Check if this is a boundary pixel
    isContourPoint = false;
    if (px == 0 || py == 0 || px == source.width - 1 || py == source.height - 1) {
      isContourPoint = true;
    } else {
      // Check 4-connected neighbors
      if (getBrightness(source.getPixel(px - 1, py)) <= 127 ||
          getBrightness(source.getPixel(px + 1, py)) <= 127 ||
          getBrightness(source.getPixel(px, py - 1)) <= 127 ||
          getBrightness(source.getPixel(px, py + 1)) <= 127) {
        isContourPoint = true;
      }
    }
    
    if (isContourPoint) {
      contour.add([px, py]);
    }
    
    // Add 4-connected neighbors to stack
    stack.add([px + 1, py]);
    stack.add([px - 1, py]);
    stack.add([px, py + 1]);
    stack.add([px, py - 1]);
  }
}
List<List<int>> approximateContour(List<List<int>> contour) {
  // Simple Douglas-Peucker-like algorithm to reduce contour points
  if (contour.length <= 5) return contour;
  
  double epsilon = 2.0; // Approximation precision
  List<List<int>> result = [];
  
  // Find the point with the maximum distance
  int start = 0;
  int end = contour.length - 1;
  
  result.add(contour[start]);
  
  douglasPeucker(contour, start, end, epsilon, result);
  
  result.add(contour[end]);
  
  return result;
}
void douglasPeucker(
  List<List<int>> contour, 
  int start, 
  int end, 
  double epsilon, 
  List<List<int>> result
) {
  // Base case
  if (end <= start + 1) {
    return;
  }
  
  double dmax = 0;
  int index = 0;
  
  // Line from start to end
  List<int> startPoint = contour[start];
  List<int> endPoint = contour[end];
  
  // Find the point with max distance from line
  for (int i = start + 1; i < end; i++) {
    double d = perpendicularDistance(contour[i], startPoint, endPoint);
    if (d > dmax) {
      index = i;
      dmax = d;
    }
  }
  
  // If max distance is greater than epsilon, recursively simplify
  if (dmax > epsilon) {
    douglasPeucker(contour, start, index, epsilon, result);
    result.add(contour[index]);
    douglasPeucker(contour, index, end, epsilon, result);
  }
}
double perpendicularDistance(List<int> point, List<int> lineStart, List<int> lineEnd) {
  // Calculate perpendicular distance from point to line
  double dx = lineEnd[0].toDouble() - lineStart[0].toDouble();
  double dy = lineEnd[1].toDouble() - lineStart[1].toDouble();
  
  // Normalize
  double mag = math.sqrt(dx * dx + dy * dy);
  if (mag < 1e-10) {
    return math.sqrt(math.pow(point[0].toDouble() - lineStart[0].toDouble(), 2) + 
                    math.pow(point[1].toDouble() - lineStart[1].toDouble(), 2));
  }
  
  dx /= mag;
  dy /= mag;
  
  // Perpendicular distance
  double pvx = point[0].toDouble() - lineStart[0].toDouble();
  double pvy = point[1].toDouble() - lineStart[1].toDouble();
  
  // Dot product
  double pvdot = dx * pvx + dy * pvy;
  
  // Scale line direction
  double dsx = pvdot * dx;
  double dsy = pvdot * dy;
  
  // Perpendicular vector
  double ax = pvx - dsx;
  double ay = pvy - dsy;
  
  return math.sqrt(ax * ax + ay * ay);
}
Image adaptiveThreshold(Image image, int blockSize, int c) {
  // Approximate adaptive thresholding
  Image result = Image(width: image.width, height: image.height);
  
  // Create an integral image
  List<List<int>> integral = List.generate(
    image.height + 1,
    (int i) => List.filled(image.width + 1, 0),
  );
  
  // Fill integral image
  for (int y = 0; y < image.height; y++) {
    for (int x = 0; x < image.width; x++) {
      int pixel = getBrightness(image.getPixel(x, y));
      integral[y + 1][x + 1] = pixel + 
                             integral[y][x + 1] + 
                             integral[y + 1][x] - 
                             integral[y][x];
    }
  }
  
  // Apply thresholding
  int radius = blockSize ~/ 2;
  
  for (int y = 0; y < image.height; y++) {
    for (int x = 0; x < image.width; x++) {
      // Define block bounds
      int x1 = math.max(0, x - radius);
      int y1 = math.max(0, y - radius);
      int x2 = math.min(image.width - 1, x + radius);
      int y2 = math.min(image.height - 1, y + radius);
      
      // Count pixels in block
      int count = (x2 - x1 + 1) * (y2 - y1 + 1);
      
      // Sum using integral image
      int sum = integral[y2 + 1][x2 + 1] - 
               integral[y2 + 1][x1] - 
               integral[y1][x2 + 1] + 
               integral[y1][x1];
      
      // Calculate local threshold
      int threshold = (sum ~/ count) - c;
      
      // Apply threshold
      int pixel = getBrightness(image.getPixel(x, y));
      if (pixel > threshold) {
        result.setPixel(x, y, getColor(255, 255, 255, 255));
      } else {
        result.setPixel(x, y, getColor(0, 0, 0, 255));
      }
    }
  }
  
  return result;
}
List<Image> extractChannels(Image image) {
  // Extract RGB channels
  int width = image.width;
  int height = image.height;
  
  Image red = Image(width: width, height: height);
  Image green = Image(width: width, height: height);
  Image blue = Image(width: width, height: height);
  
  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      Pixel pixel = image.getPixel(x, y);
      red.setPixel(x, y, getColor(getRed(pixel), 0, 0, 255));
      green.setPixel(x, y, getColor(0, getGreen(pixel), 0, 255));
      blue.setPixel(x, y, getColor(0, 0, getBlue(pixel), 255));
    }
  }
  
  return [red, green, blue];
}
Image threshold(Image image, int thresholdValue) {
  // Create output image
  Image result = Image(width: image.width, height: image.height);
  
  // Apply threshold to each pixel
  for (int y = 0; y < image.height; y++) {
    for (int x = 0; x < image.width; x++) {
      int brightness = getBrightness(image.getPixel(x, y));
      if (brightness > thresholdValue) {
        result.setPixel(x, y, getColor(255, 255, 255, 255));
      } else {
        result.setPixel(x, y, getColor(0, 0, 0, 255));
      }
    }
  }
  
  return result;
}
Image adjustContrast(Image image) {
  // Apply contrast enhancement (simplified CLAHE)
  Image result = image.clone();
  
  // For now, just return the original image until we implement contrast adjustment
  return result;
}
Polygon scalePolygon(Polygon polygon, double xfact, double yfact) {
  // Scale polygon about its centroid
  Point2D centroid = polygon.centroid();
  List<Point2D> newVertices = [];
  
  for (Point2D point in polygon.vertices) {
    double newX = centroid.x + xfact * (point.x - centroid.x);
    double newY = centroid.y + yfact * (point.y - centroid.y);
    newVertices.add(Point2D(newX, newY));
  }
  
  return Polygon(newVertices);
}// File: lib/geometry/polygons.dart
import 'dart:math' as math;
class Point2D {
  final double x;
  final double y;
  
  const Point2D(this.x, this.y);
  
  // Helper methods for points
  double distanceTo(Point2D other) {
    double dx = x - other.x;
    double dy = y - other.y;
    return math.sqrt(dx * dx + dy * dy);
  }
  
  @override
  String toString() => 'Point2D($x, $y)';
}
class Line {
  final Point2D p1;
  final Point2D p2;
  
  const Line(this.p1, this.p2);
  
  // Create a line from two points
  factory Line.fromPoints(Point2D point1, Point2D point2) {
    return Line(point1, point2);
  }
  
  // Intersect this line with another line
  Point2D? intersect(Line other) {
    // Convert the lines to the format expected by lineIntersection
    List<double> x = [p1.x, p2.x, other.p1.x, other.p2.x];
    List<double> y = [p1.y, p2.y, other.p1.y, other.p2.y];
    
    Point2D intersection = lineIntersection(x, y);
    
    // Check if the lines are parallel (result will be NaN)
    if (intersection.x.isNaN || intersection.y.isNaN) {
      return null;
    }
    
    return intersection;
  }
}
class Polygon {
  final List<Point2D> vertices;
  
  const Polygon(this.vertices);
  
  double area() {
    // Calculate area using Shoelace formula
    double area = 0.0;
    int n = vertices.length;
    
    for (int i = 0; i < n; i++) {
      Point2D current = vertices[i];
      Point2D next = vertices[(i + 1) % n];
      area += (current.x * next.y - next.x * current.y);
    }
    
    return area.abs() / 2.0;
  }
  
  double perimeter() {
    double perimeter = 0.0;
    int n = vertices.length;
    
    for (int i = 0; i < n; i++) {
      Point2D current = vertices[i];
      Point2D next = vertices[(i + 1) % n];
      perimeter += current.distanceTo(next);
    }
    
    return perimeter;
  }
  
  Point2D centroid() {
    // Calculate centroid
    double cx = 0.0;
    double cy = 0.0;
    
    for (var vertex in vertices) {
      cx += vertex.x;
      cy += vertex.y;
    }
    
    return Point2D(cx / vertices.length, cy / vertices.length);
  }
  
  bool contains(Polygon other) {
    // Check if all vertices of the other polygon are inside this one
    for (var vertex in other.vertices) {
      if (!_pointInPolygon(vertex)) {
        return false;
      }
    }
    return true;
  }
  
  bool _pointInPolygon(Point2D point) {
    // Ray casting algorithm to determine if a point is inside a polygon
    bool inside = false;
    int n = vertices.length;
    
    for (int i = 0, j = n - 1; i < n; j = i++) {
      if (((vertices[i].y > point.y) != (vertices[j].y > point.y)) &&
          (point.x < (vertices[j].x - vertices[i].x) * (point.y - vertices[i].y) / 
           (vertices[j].y - vertices[i].y) + vertices[i].x)) {
        inside = !inside;
      }
    }
    
    return inside;
  }
  
  Polygon? intersection(Polygon other) {
    // Simplified implementation: check if one contains the other
    if (contains(other)) {
      return other;
    } else if (other.contains(this)) {
      return this;
    }
    
    // For a more accurate intersection, we'd need a more complex algorithm
    // This is a simplification for the current use case
    return null;
  }
}
Point2D lineIntersection(List<double> x, List<double> y) {
  // Calculate the intersection point of two lines
  // Lines defined by points (x[0],y[0]), (x[1],y[1]) and (x[2],y[2]), (x[3],y[3])
  
  double slope0 = (x[0] - x[1]) * (y[2] - y[3]);
  double slope2 = (y[0] - y[1]) * (x[2] - x[3]);
  
  if (slope0 == slope2) {
    // Parallel lines
    return Point2D(double.nan, double.nan);
  }
  
  double xy01 = x[0] * y[1] - y[0] * x[1];
  double xy23 = x[2] * y[3] - y[2] * x[3];
  double denom = slope0 - slope2;
  
  double xis = (xy01 * (x[2] - x[3]) - (x[0] - x[1]) * xy23) / denom;
  double yis = (xy01 * (y[2] - y[3]) - (y[0] - y[1]) * xy23) / denom;
  
  return Point2D(xis, yis);
}
Polygon simplifyPolygon(Polygon inPoly, {double lengthCutoff = 0.15, int? maxIter, int? segmentToRemove}) {
  // Simplifies a polygon by removing short segments
  List<Point2D> points = List.from(inPoly.vertices);
  int lenPoly = points.length;
  int niter = 0;
  
  if (segmentToRemove != null) {
    maxIter = 1;
  }
  
  while (lenPoly > 4) {
    // Calculate distances between consecutive points
    List<double> distances = [];
    double dTotal = 0.0;
    
    for (int i = 0; i < lenPoly; i++) {
      int nextIdx = (i + 1) % lenPoly;
      double dx = points[i].x - points[nextIdx].x;
      double dy = points[i].y - points[nextIdx].y;
      double d = math.sqrt(dx * dx + dy * dy);
      distances.add(d);
      dTotal += d;
    }
    
    // Find shortest segment if not specified
    int k = segmentToRemove ?? distances.indexOf(distances.reduce(math.min));
    
    if (distances[k] < lengthCutoff * dTotal) {
      // Generate indices for the segments to extend
      List<int> ind = generatePointIndices(k - 1, k + 1, lenPoly);
      
      // Calculate new intersection point
      Point2D intersection = lineIntersection(
        [points[ind[0]].x, points[ind[1]].x, points[ind[2]].x, points[ind[3]].x],
        [points[ind[0]].y, points[ind[1]].y, points[ind[2]].y, points[ind[3]].y]
      );
      
      // Replace point K with intersection
      points[k] = intersection;
      
      // Remove the next point (shortens the polygon)
      points.removeAt((k + 1) % lenPoly);
      lenPoly = points.length;
      
      niter++;
      if (maxIter != null && niter >= maxIter) {
        break;
      }
    } else {
      break;
    }
  }
  
  return Polygon(points);
}
List<int> generatePointIndices(int index1, int index2, int maxLen) {
  // Returns the four indices for polygon segments
  return [
    index1 % maxLen,
    (index1 + 1) % maxLen,
    index2 % maxLen,
    (index2 + 1) % maxLen
  ];
}
List<Point2D> generateQuadCorners(List<int> indices, List<Point2D> points) {
  int i = indices[0], j = indices[1], k = indices[2], l = indices[3];
  List<double> x = points.map((p) => p.x).toList();
  List<double> y = points.map((p) => p.y).toList();
  
  List<Point2D> corners = List.filled(4, Point2D(double.nan, double.nan));
  
  if (j <= i || k <= j || l <= k) {
    return corners;
  }
  
  corners[0] = lineIntersection(
    [x[i], x[(i + 1) % points.length], x[j], x[(j + 1) % points.length]],
    [y[i], y[(i + 1) % points.length], y[j], y[(j + 1) % points.length]]
  );
  
  corners[1] = lineIntersection(
    [x[j], x[(j + 1) % points.length], x[k], x[(k + 1) % points.length]],
    [y[j], y[(j + 1) % points.length], y[k], y[(k + 1) % points.length]]
  );
  
  corners[2] = lineIntersection(
    [x[k], x[(k + 1) % points.length], x[l], x[(l + 1) % points.length]],
    [y[k], y[(k + 1) % points.length], y[l], y[(l + 1) % points.length]]
  );
  
  corners[3] = lineIntersection(
    [x[l], x[(l + 1) % points.length], x[i], x[(i + 1) % points.length]],
    [y[l], y[(l + 1) % points.length], y[i], y[(i + 1) % points.length]]
  );
  
  return corners;
}
List<Polygon> generateQuadCandidates(Polygon inPoly) {
  // Generate candidate quadrilaterals that bound the polygon
  
  // Sort the points in angular order
  List<Point2D> points = List.from(inPoly.vertices);
  
  // Calculate center
  double xAvg = 0, yAvg = 0;
  for (var p in points) {
    xAvg += p.x;
    yAvg += p.y;
  }
  xAvg /= points.length;
  yAvg /= points.length;
  
  // Create a slightly shrunken polygon to test containment
  List<Point2D> shrunkPoints = [];
  for (var p in points) {
    shrunkPoints.add(Point2D(
      xAvg + 0.9999 * (p.x - xAvg),
      yAvg + 0.9999 * (p.y - yAvg)
    ));
  }
  Polygon shrunkPoly = Polygon(shrunkPoints);
  
  List<Polygon> quads = [];
  
  // Generate all possible combinations of 4 line intersections
  // This is a simplification of the Python's itertools.product
  for (int i = 0; i < points.length; i++) {
    for (int j = i + 1; j < points.length; j++) {
      for (int k = j + 1; k < points.length; k++) {
        for (int l = k + 1; l < points.length; l++) {
          List<Point2D> corners = generateQuadCorners([i, j, k, l], points);
          
          // Check if any point is NaN (no intersection)
          bool hasNaN = corners.any((p) => p.x.isNaN || p.y.isNaN);
          if (hasNaN) continue;
          
          // Create a quad from the corners
          Polygon quad = Polygon(corners);
          
          // Test if the quad contains the original polygon
          if (quad.contains(shrunkPoly)) {
            quads.add(quad);
          }
        }
      }
    }
  }
  
  return quads;
}
Polygon getBoundingQuad(Polygon hullPoly) {
  // Get the minimum-area quadrilateral that bounds the given polygon
  
  Polygon simplePoly = simplifyPolygon(hullPoly);
  List<Polygon> boundingQuads = generateQuadCandidates(simplePoly);
  
  if (boundingQuads.isEmpty) {
    // If no quads were found, return the original polygon
    return hullPoly;
  }
  
  // Find the quad with minimum area
  Polygon minAreaQuad = boundingQuads[0];
  double minArea = minAreaQuad.area();
  
  for (int i = 1; i < boundingQuads.length; i++) {
    double area = boundingQuads[i].area();
    if (area < minArea) {
      minArea = area;
      minAreaQuad = boundingQuads[i];
    }
  }
  
  return minAreaQuad;
}
double quadCornerDiff(Polygon hullPoly, Polygon bquadPoly, [double regionSize = 0.9]) {
  // Calculate the difference between the quad corners and the hull
  List<Point2D> bquadCorners = bquadPoly.vertices;
  
  // Calculate quad center
  double xAvg = 0, yAvg = 0;
  for (var p in bquadCorners) {
    xAvg += p.x;
    yAvg += p.y;
  }
  xAvg /= bquadCorners.length;
  yAvg /= bquadCorners.length;
  
  // Calculate interior points (moved towards center by regionSize)
  List<Point2D> interiorPoints = [];
  for (var p in bquadCorners) {
    interiorPoints.add(Point2D(
      xAvg + regionSize * (p.x - xAvg),
      yAvg + regionSize * (p.y - yAvg)
    ));
  }
  
  // Calculate points for orthogonal line through interior point
  List<double> p0X = [], p1X = [], p0Y = [], p1Y = [];
  for (int i = 0; i < interiorPoints.length; i++) {
    p0X.add(interiorPoints[i].x + (bquadCorners[i].y - yAvg));
    p1X.add(interiorPoints[i].x - (bquadCorners[i].y - yAvg));
    p0Y.add(interiorPoints[i].y - (bquadCorners[i].x - xAvg));
    p1Y.add(interiorPoints[i].y + (bquadCorners[i].x - xAvg));
  }
  
  // Calculate corner area polygons
  double hullCornerArea = 0;
  double quadCornerArea = 0;
  
  for (int i = 0; i < bquadCorners.length; i++) {
    // Create a line from p0 to p1
    Line line = Line.fromPoints(
      Point2D(p0X[i], p0Y[i]),
      Point2D(p1X[i], p1Y[i])
    );
    
    // Find intersection of line with quad
    List<Point2D> intersections = [];
    for (int j = 0; j < bquadCorners.length; j++) {
      int next = (j + 1) % bquadCorners.length;
      Line edge = Line.fromPoints(bquadCorners[j], bquadCorners[next]);
      Point2D? intersection = line.intersect(edge);
      if (intersection != null) {
        intersections.add(intersection);
      }
    }
    
    if (intersections.length < 2) continue;
    
    // Create corner polygon from two intersection points and corner
    List<Point2D> cornerPoints = [
      intersections[0],
      intersections[1],
      bquadCorners[i]
    ];
    Polygon cornerPoly = Polygon(cornerPoints);
    
    // Add to areas
    quadCornerArea += cornerPoly.area();
    
    // Calculate intersection with hull
    Polygon? intersection = cornerPoly.intersection(hullPoly);
    if (intersection != null) {
      hullCornerArea += intersection.area();
    }
  }
  
  return quadCornerArea > 0 ? 1.0 - hullCornerArea / quadCornerArea : 0.0;
}
Polygon convexHullPolygon(List<List<int>> contour) {
  // OpenCV contour to convex hull polygon
  
  // Extract points from contour format
  List<Point2D> points = [];
  for (var point in contour) {
    points.add(Point2D(point[0].toDouble(), point[1].toDouble()));
  }
  
  // Calculate convex hull using Graham scan algorithm
  List<Point2D> hull = grahamScan(points);
  return Polygon(hull);
}
List<Point2D> grahamScan(List<Point2D> points) {
  if (points.length <= 3) return List.from(points);
  
  // Find the point with lowest y-coordinate (and leftmost if tied)
  Point2D pivot = points[0];
  for (int i = 1; i < points.length; i++) {
    if (points[i].y < pivot.y || 
        (points[i].y == pivot.y && points[i].x < pivot.x)) {
      pivot = points[i];
    }
  }
  
  // Sort points by polar angle with respect to pivot
  List<Point2D> sortedPoints = List.from(points);
  sortedPoints.remove(pivot);
  
  sortedPoints.sort((a, b) {
    double angleA = math.atan2(a.y - pivot.y, a.x - pivot.x);
    double angleB = math.atan2(b.y - pivot.y, b.x - pivot.x);
    
    if (angleA < angleB) return -1;
    if (angleA > angleB) return 1;
    
    // If angles are equal, take the point farther from pivot
    double distA = (a.x - pivot.x) * (a.x - pivot.x) + 
                   (a.y - pivot.y) * (a.y - pivot.y);
    double distB = (b.x - pivot.x) * (b.x - pivot.x) + 
                   (b.y - pivot.y) * (b.y - pivot.y);
    
    return distA > distB ? -1 : 1;
  });
  
  // Build hull
  List<Point2D> hull = [pivot, sortedPoints[0]];
  
  for (int i = 1; i < sortedPoints.length; i++) {
    while (hull.length > 1 && 
           !isLeftTurn(hull[hull.length - 2], hull[hull.length - 1], sortedPoints[i])) {
      hull.removeLast();
    }
    hull.add(sortedPoints[i]);
  }
  
  return hull;
}
bool isLeftTurn(Point2D a, Point2D b, Point2D c) {
  return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) > 0;
}
double polygonFormFactor(Polygon poly) {
  // Calculate the form factor (ratio of area to perimeter scaled by min edge)
  List<Point2D> points = poly.vertices;
  
  // Find minimum side length
  double minLength = double.infinity;
  for (int i = 0; i < points.length; i++) {
    int next = (i + 1) % points.length;
    double dx = points[i].x - points[next].x;
    double dy = points[i].y - points[next].y;
    double dist = math.sqrt(dx * dx + dy * dy);
    if (dist < minLength) {
      minLength = dist;
    }
  }
  
  // Calculate perimeter
  double perimeter = poly.perimeter();
  
  return poly.area() / (perimeter * minLength);
}
class CardContourResult {
  final bool continueSegmentation;
  final bool isCardCandidate;
  final Polygon? boundingPoly;
  final double cropFactor;
  
  CardContourResult(
    this.continueSegmentation,
    this.isCardCandidate,
    this.boundingPoly,
    this.cropFactor
  );
}
CardContourResult characterizeCardContour(
    List<List<int>> cardContour,
    double maxSegmentArea,
    double imageArea) {
  
  try {
    Polygon phull = convexHullPolygon(cardContour);
    
    if (phull.area() < 0.1 * maxSegmentArea || phull.area() < imageArea / 1000.0) {
      // Too small to be a card, or we've explored enough of the image
      return CardContourResult(false, false, null, 1.0);
    }
    
    Polygon boundingPoly = getBoundingQuad(phull);
    double qcDiff = quadCornerDiff(phull, boundingPoly);
    double cropFactor = math.min(1.0, (1.0 - qcDiff * 22.0 / 100.0));
    
    bool isCardCandidate = 
      0.1 * maxSegmentArea < boundingPoly.area() &&
      boundingPoly.area() < imageArea * 0.99 &&
      qcDiff < 0.35 &&
      0.25 < polygonFormFactor(boundingPoly) && 
      polygonFormFactor(boundingPoly) < 0.33;
    
    return CardContourResult(true, isCardCandidate, boundingPoly, cropFactor);
  } catch (e) {
    // Handle exceptions (e.g., degenerate geometries)
    print('Error in characterizeCardContour: $e');
    return CardContourResult(true, false, null, 1.0);
  }
}// File: lib/geometry/transforms.dart
import 'dart:math' as math;
import 'package:image/image.dart';
import 'polygons.dart'; // Import our custom Point2D and Polygon classes
import 'matrix.dart'; // Import our Matrix4 and Vector4 classes
int getRed(Pixel pixel) => pixel.r.toInt();
int getGreen(Pixel pixel) => pixel.g.toInt();
int getBlue(Pixel pixel) => pixel.b.toInt();
int getAlpha(Pixel pixel) => pixel.a.toInt();
Color getColor(int r, int g, int b, int a) => ColorRgba8(r, g, b, a);
List<Point2D> orderPolygonPoints(List<Point2D> points) {
  // First calculate center
  double centerX = 0.0;
  double centerY = 0.0;
  for (var point in points) {
    centerX += point.x;
    centerY += point.y;
  }
  centerX /= points.length;
  centerY /= points.length;
  
  // Calculate angles of points relative to center
  List<Map<String, dynamic>> pointsWithAngles = [];
  for (var point in points) {
    double angle = math.atan2(point.y - centerY, point.x - centerX);
    pointsWithAngles.add({
      'point': point,
      'angle': angle
    });
  }
  
  // Sort by angle
  pointsWithAngles.sort((a, b) => a['angle'].compareTo(b['angle']));
  
  // Return sorted points
  return pointsWithAngles.map((p) => p['point'] as Point2D).toList();
}
Image fourPointTransform(Image image, Polygon quad) {
  // Get vertices from polygon
  List<Point2D> points = quad.vertices;
  
  // Order the points consistently
  points = orderPolygonPoints(points);
  
  // Compute width of new image (max distance between points horizontally)
  double widthA = points[1].distanceTo(points[0]);
  double widthB = points[2].distanceTo(points[3]);
  int maxWidth = math.max(widthA.toInt(), widthB.toInt());
  
  // Compute height of new image (max distance between points vertically)
  double heightA = points[3].distanceTo(points[0]);
  double heightB = points[2].distanceTo(points[1]);
  int maxHeight = math.max(heightA.toInt(), heightB.toInt());
  
  // Create perspective transform matrix
  List<double> sourcePoints = [];
  for (var point in points) {
    sourcePoints.add(point.x);
    sourcePoints.add(point.y);
  }
  
  List<double> destPoints = [
    0, 0,
    maxWidth - 1, 0,
    maxWidth - 1, maxHeight - 1,
    0, maxHeight - 1
  ];
  
  // Calculate the perspective transform matrix
  Matrix4 transform = getPerspectiveTransform(sourcePoints, destPoints);
  
  // Apply the perspective transformation
  return perspectiveTransform(image, transform, maxWidth, maxHeight);
}
Matrix4 getPerspectiveTransform(List<double> src, List<double> dst) {
  // Source points
  final double x0 = src[0], y0 = src[1];
  final double x1 = src[2], y1 = src[3];
  final double x2 = src[4], y2 = src[5];
  final double x3 = src[6], y3 = src[7];
  
  // Destination points - change to lowerCamelCase to follow Dart conventions
  final double x0Dst = dst[0], y0Dst = dst[1];
  final double x1Dst = dst[2], y1Dst = dst[3];
  final double x2Dst = dst[4], y2Dst = dst[5];
  final double x3Dst = dst[6], y3Dst = dst[7];
  
  // Calculate coefficients for the system of equations
  final double a = (x1 - x2) * (y0 - y2) - (x0 - x2) * (y1 - y2);
  final double b = (x3 - x2) * (y0 - y2) - (x0 - x2) * (y3 - y2);
  final double c = x0Dst - x2Dst;
  final double d = x1Dst - x2Dst;
  final double e = x3Dst - x2Dst;
  final double f = y0Dst - y2Dst;
  final double g = y1Dst - y2Dst;
  final double h = y3Dst - y2Dst;
  
  // Solve for the transformation matrix parameters
  final double A = (a * e - b * d) / (a * h - b * g);
  final double B = (a * h - b * g != 0) ? (c * h - e * f) / (a * h - b * g) : 0;
  final double C = x2Dst;
  
  final double D = (a * h - b * g != 0) ? (d * h - e * g) / (a * h - b * g) : 0;
  final double E = (a * h - b * g != 0) ? (f * d - c * g) / (a * h - b * g) : 0;
  final double F = y2Dst;
  
  final double G = (a != 0) ? ((x0 - x2) * A + (y0 - y2) * D) / (x0 - x2) : 
                   (b != 0) ? ((x3 - x2) * A + (y3 - y2) * D) / (x3 - x2) : 0;
  final double H = (a != 0) ? ((x0 - x2) * B + (y0 - y2) * E) / (x0 - x2) : 
                   (b != 0) ? ((x3 - x2) * B + (y3 - y2) * E) / (x3 - x2) : 0;
  
  // Create homography matrix
  return Matrix4(
    A, D, 0, G,
    B, E, 0, H,
    0, 0, 1, 0,
    C, F, 0, 1
  );
}
Image perspectiveTransform(Image src, Matrix4 transform, int width, int height) {
  // Create a new destination image with the specified dimensions
  Image dst = Image(width: width, height: height);
  
  try {
    // Compute inverse transform
    Matrix4 inverseTransform = Matrix4.clone(transform);
    inverseTransform.invert();
    
    // For each pixel in the destination image
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        // Apply inverse transform to get source coordinates
        Vector4 srcVec = inverseTransform.transform(Vector4(x.toDouble(), y.toDouble(), 0, 1));
        
        // Normalize homogeneous coordinates
        if (srcVec.w.abs() < 1e-10) {
          continue; // Skip if w is close to zero (avoid division by zero)
        }
        
        double srcX = srcVec.x / srcVec.w;
        double srcY = srcVec.y / srcVec.w;
        
        // Skip if out of bounds
        if (srcX < 0 || srcX >= src.width || srcY < 0 || srcY >= src.height) {
          continue;
        }
        
        // Bilinear interpolation to get the color at the source coordinates
        Color color = interpolateColor(src, srcX, srcY);
        
        // Set the pixel in the destination image
        dst.setPixel(x, y, color);
      }
    }
  } catch (e) {
    print('Error during perspective transform: $e');
    // Return a simple copy of the source image if transformation fails
    return src.clone();
  }
  
  return dst;
}
Color interpolateColor(Image src, double x, double y) {
  // Get four surrounding pixel coordinates
  int x0 = x.floor();
  int y0 = y.floor();
  int x1 = math.min(x0 + 1, src.width - 1);
  int y1 = math.min(y0 + 1, src.height - 1);
  
  // Calculate interpolation weights
  double wx = x - x0;
  double wy = y - y0;
  
  // First try using the built-in image package interpolation
  try {
    return src.getPixelInterpolate(x, y);
  } catch (_) {
    try {
      // Try the older getPixelLinear method
      return src.getPixelLinear(x, y);
    } catch (_) {
      // Continue with manual interpolation
    }
  }
  
  // Fallback to manual interpolation if needed
  // Get colors of four surrounding pixels
  Pixel c00 = src.getPixel(x0, y0);
  Pixel c10 = src.getPixel(x1, y0);
  Pixel c01 = src.getPixel(x0, y1);
  Pixel c11 = src.getPixel(x1, y1);
  
  // Extract RGB components
  int r00 = getRed(c00), g00 = getGreen(c00), b00 = getBlue(c00), a00 = getAlpha(c00);
  int r10 = getRed(c10), g10 = getGreen(c10), b10 = getBlue(c10), a10 = getAlpha(c10);
  int r01 = getRed(c01), g01 = getGreen(c01), b01 = getBlue(c01), a01 = getAlpha(c01);
  int r11 = getRed(c11), g11 = getGreen(c11), b11 = getBlue(c11), a11 = getAlpha(c11);
  
  // Interpolate color components
  int r = (r00 * (1 - wx) * (1 - wy) + r10 * wx * (1 - wy) + r01 * (1 - wx) * wy + r11 * wx * wy).round();
  int g = (g00 * (1 - wx) * (1 - wy) + g10 * wx * (1 - wy) + g01 * (1 - wx) * wy + g11 * wx * wy).round();
  int b = (b00 * (1 - wx) * (1 - wy) + b10 * wx * (1 - wy) + b01 * (1 - wx) * wy + b11 * wx * wy).round();
  int a = (a00 * (1 - wx) * (1 - wy) + a10 * wx * (1 - wy) + a01 * (1 - wx) * wy + a11 * wx * wy).round();
  
  // Ensure values are within valid range
  r = math.min(255, math.max(0, r));
  g = math.min(255, math.max(0, g));
  b = math.min(255, math.max(0, b));
  a = math.min(255, math.max(0, a));
  
  // Combine components back to a color
  return getColor(r, g, b, a);
}// File: lib/geometry/matrix.dart
class Vector4 {
  double x;
  double y;
  double z;
  double w;
  
  Vector4(this.x, this.y, this.z, this.w);
  
  @override
  String toString() => 'Vector4($x, $y, $z, $w)';
}
class Matrix4 {
  // Row-major order: data[row][column]
  List<List<double>> data;
  
  Matrix4(double a, double b, double c, double d,
          double e, double f, double g, double h,
          double i, double j, double k, double l,
          double m, double n, double o, double p)
      : data = [
          [a, b, c, d],
          [e, f, g, h],
          [i, j, k, l],
          [m, n, o, p]
        ];
  
  factory Matrix4.clone(Matrix4 other) {
    return Matrix4(
      other.data[0][0], other.data[0][1], other.data[0][2], other.data[0][3],
      other.data[1][0], other.data[1][1], other.data[1][2], other.data[1][3],
      other.data[2][0], other.data[2][1], other.data[2][2], other.data[2][3],
      other.data[3][0], other.data[3][1], other.data[3][2], other.data[3][3]
    );
  }
  
  // A simplified 3D transform method
  Vector4 transform(Vector4 v) {
    // Perform matrix multiplication
    final x = data[0][0] * v.x + data[0][1] * v.y + data[0][2] * v.z + data[0][3] * v.w;
    final y = data[1][0] * v.x + data[1][1] * v.y + data[1][2] * v.z + data[1][3] * v.w;
    final z = data[2][0] * v.x + data[2][1] * v.y + data[2][2] * v.z + data[2][3] * v.w;
    final w = data[3][0] * v.x + data[3][1] * v.y + data[3][2] * v.z + data[3][3] * v.w;
    
    return Vector4(x, y, z, w);
  }
  
  // Inverts the matrix for perspective transform
  void invert() {
    final det = determinant();
    if (det.abs() < 1e-10) {
      throw Exception('Matrix is singular and cannot be inverted');
    }
    
    // Create a temporary copy of the matrix
    final temp = Matrix4.clone(this);
    
    // Calculate the adjugate matrix
    data[0][0] = (temp.data[1][1] * (temp.data[2][2] * temp.data[3][3] - temp.data[2][3] * temp.data[3][2]) -
                  temp.data[1][2] * (temp.data[2][1] * temp.data[3][3] - temp.data[2][3] * temp.data[3][1]) +
                  temp.data[1][3] * (temp.data[2][1] * temp.data[3][2] - temp.data[2][2] * temp.data[3][1])) / det;
    
    data[0][1] = (temp.data[0][1] * (temp.data[2][3] * temp.data[3][2] - temp.data[2][2] * temp.data[3][3]) +
                  temp.data[0][2] * (temp.data[2][1] * temp.data[3][3] - temp.data[2][3] * temp.data[3][1]) +
                  temp.data[0][3] * (temp.data[2][2] * temp.data[3][1] - temp.data[2][1] * temp.data[3][2])) / det;
    
    data[0][2] = (temp.data[0][1] * (temp.data[1][2] * temp.data[3][3] - temp.data[1][3] * temp.data[3][2]) +
                  temp.data[0][2] * (temp.data[1][3] * temp.data[3][1] - temp.data[1][1] * temp.data[3][3]) +
                  temp.data[0][3] * (temp.data[1][1] * temp.data[3][2] - temp.data[1][2] * temp.data[3][1])) / det;
    
    data[0][3] = (temp.data[0][1] * (temp.data[1][3] * temp.data[2][2] - temp.data[1][2] * temp.data[2][3]) +
                  temp.data[0][2] * (temp.data[1][1] * temp.data[2][3] - temp.data[1][3] * temp.data[2][1]) +
                  temp.data[0][3] * (temp.data[1][2] * temp.data[2][1] - temp.data[1][1] * temp.data[2][2])) / det;
    
    data[1][0] = (temp.data[1][0] * (temp.data[2][3] * temp.data[3][2] - temp.data[2][2] * temp.data[3][3]) +
                  temp.data[1][2] * (temp.data[2][0] * temp.data[3][3] - temp.data[2][3] * temp.data[3][0]) +
                  temp.data[1][3] * (temp.data[2][2] * temp.data[3][0] - temp.data[2][0] * temp.data[3][2])) / det;
    
    data[1][1] = (temp.data[0][0] * (temp.data[2][2] * temp.data[3][3] - temp.data[2][3] * temp.data[3][2]) +
                  temp.data[0][2] * (temp.data[2][3] * temp.data[3][0] - temp.data[2][0] * temp.data[3][3]) +
                  temp.data[0][3] * (temp.data[2][0] * temp.data[3][2] - temp.data[2][2] * temp.data[3][0])) / det;
    
    data[1][2] = (temp.data[0][0] * (temp.data[1][3] * temp.data[3][2] - temp.data[1][2] * temp.data[3][3]) +
                  temp.data[0][2] * (temp.data[1][0] * temp.data[3][3] - temp.data[1][3] * temp.data[3][0]) +
                  temp.data[0][3] * (temp.data[1][2] * temp.data[3][0] - temp.data[1][0] * temp.data[3][2])) / det;
    
    data[1][3] = (temp.data[0][0] * (temp.data[1][2] * temp.data[2][3] - temp.data[1][3] * temp.data[2][2]) +
                  temp.data[0][2] * (temp.data[1][3] * temp.data[2][0] - temp.data[1][0] * temp.data[2][3]) +
                  temp.data[0][3] * (temp.data[1][0] * temp.data[2][2] - temp.data[1][2] * temp.data[2][0])) / det;
    
    data[2][0] = (temp.data[1][0] * (temp.data[2][1] * temp.data[3][3] - temp.data[2][3] * temp.data[3][1]) +
                  temp.data[1][1] * (temp.data[2][3] * temp.data[3][0] - temp.data[2][0] * temp.data[3][3]) +
                  temp.data[1][3] * (temp.data[2][0] * temp.data[3][1] - temp.data[2][1] * temp.data[3][0])) / det;
    
    data[2][1] = (temp.data[0][0] * (temp.data[2][3] * temp.data[3][1] - temp.data[2][1] * temp.data[3][3]) +
                  temp.data[0][1] * (temp.data[2][0] * temp.data[3][3] - temp.data[2][3] * temp.data[3][0]) +
                  temp.data[0][3] * (temp.data[2][1] * temp.data[3][0] - temp.data[2][0] * temp.data[3][1])) / det;
    
    data[2][2] = (temp.data[0][0] * (temp.data[1][1] * temp.data[3][3] - temp.data[1][3] * temp.data[3][1]) +
                  temp.data[0][1] * (temp.data[1][3] * temp.data[3][0] - temp.data[1][0] * temp.data[3][3]) +
                  temp.data[0][3] * (temp.data[1][0] * temp.data[3][1] - temp.data[1][1] * temp.data[3][0])) / det;
    
    data[2][3] = (temp.data[0][0] * (temp.data[1][3] * temp.data[2][1] - temp.data[1][1] * temp.data[2][3]) +
                  temp.data[0][1] * (temp.data[1][0] * temp.data[2][3] - temp.data[1][3] * temp.data[2][0]) +
                  temp.data[0][3] * (temp.data[1][1] * temp.data[2][0] - temp.data[1][0] * temp.data[2][1])) / det;
    
    data[3][0] = (temp.data[1][0] * (temp.data[2][2] * temp.data[3][1] - temp.data[2][1] * temp.data[3][2]) +
                  temp.data[1][1] * (temp.data[2][0] * temp.data[3][2] - temp.data[2][2] * temp.data[3][0]) +
                  temp.data[1][2] * (temp.data[2][1] * temp.data[3][0] - temp.data[2][0] * temp.data[3][1])) / det;
    
    data[3][1] = (temp.data[0][0] * (temp.data[2][1] * temp.data[3][2] - temp.data[2][2] * temp.data[3][1]) +
                  temp.data[0][1] * (temp.data[2][2] * temp.data[3][0] - temp.data[2][0] * temp.data[3][2]) +
                  temp.data[0][2] * (temp.data[2][0] * temp.data[3][1] - temp.data[2][1] * temp.data[3][0])) / det;
    
    data[3][2] = (temp.data[0][0] * (temp.data[1][2] * temp.data[3][1] - temp.data[1][1] * temp.data[3][2]) +
                  temp.data[0][1] * (temp.data[1][0] * temp.data[3][2] - temp.data[1][2] * temp.data[3][0]) +
                  temp.data[0][2] * (temp.data[1][1] * temp.data[3][0] - temp.data[1][0] * temp.data[3][1])) / det;
    
    data[3][3] = (temp.data[0][0] * (temp.data[1][1] * temp.data[2][2] - temp.data[1][2] * temp.data[2][1]) +
                  temp.data[0][1] * (temp.data[1][2] * temp.data[2][0] - temp.data[1][0] * temp.data[2][2]) +
                  temp.data[0][2] * (temp.data[1][0] * temp.data[2][1] - temp.data[1][1] * temp.data[2][0])) / det;
  }
  
  double determinant() {
    // Complete 4x4 matrix determinant calculation
    return 
      data[0][0] * (
        data[1][1] * (data[2][2] * data[3][3] - data[2][3] * data[3][2]) -
        data[1][2] * (data[2][1] * data[3][3] - data[2][3] * data[3][1]) +
        data[1][3] * (data[2][1] * data[3][2] - data[2][2] * data[3][1])
      ) -
      data[0][1] * (
        data[1][0] * (data[2][2] * data[3][3] - data[2][3] * data[3][2]) -
        data[1][2] * (data[2][0] * data[3][3] - data[2][3] * data[3][0]) +
        data[1][3] * (data[2][0] * data[3][2] - data[2][2] * data[3][0])
      ) +
      data[0][2] * (
        data[1][0] * (data[2][1] * data[3][3] - data[2][3] * data[3][1]) -
        data[1][1] * (data[2][0] * data[3][3] - data[2][3] * data[3][0]) +
        data[1][3] * (data[2][0] * data[3][1] - data[2][1] * data[3][0])
      ) -
      data[0][3] * (
        data[1][0] * (data[2][1] * data[3][2] - data[2][2] * data[3][1]) -
        data[1][1] * (data[2][0] * data[3][2] - data[2][2] * data[3][0]) +
        data[1][2] * (data[2][0] * data[3][1] - data[2][1] * data[3][0])
      );
  }
}// File: lib/mcd_dart.dart
export 'core/detector.dart';
export 'core/recognition.dart';
export 'models/card.dart';
export 'models/image.dart';
export 'geometry/polygons.dart';
export 'geometry/transforms.dart';
export 'image/processing.dart';
export 'utils/config.dart';
export 'utils/image_hash.dart';
export 'utils/scryfall_client.dart';// File: lib/magic_card_detector.dart
import 'dart:io';
import 'dart:typed_data';
import 'package:args/args.dart';
import 'package:fast_log/fast_log.dart';
import 'package:path/path.dart' as path;
import 'package:mcd_dart/mcd_dart.dart';
void main(List<String> arguments) async {
  // Parse command-line arguments
  ArgParser parser = ArgParser()
    ..addOption('input', abbr: 'i', help: 'Path to input image or directory', mandatory: true)
    ..addOption('output', abbr: 'o', help: 'Path to output directory', defaultsTo: Config.defaultResultsDirectory)
    ..addOption('reference', abbr: 'r', help: 'Path to reference hash file', defaultsTo: Config.getDefaultReferenceHashPath())
    ..addFlag('all-sets', abbr: 'a', help: 'Load all available set hashes', defaultsTo: false)
    ..addFlag('verbose', abbr: 'v', help: 'Enable verbose output', defaultsTo: false)
    ..addFlag('visual', abbr: 'd', help: 'Enable visualization (requires GUI)', defaultsTo: false)
    ..addFlag('help', abbr: 'h', help: 'Show this help message', defaultsTo: false);
  try {
    ArgResults results = parser.parse(arguments);
    if (results['help'] as bool) {
      printUsage(parser);
      exit(0);
    }
    // Get parameters
    String inputPath = results['input'] as String;
    String outputPath = results['output'] as String;
    String refHashPath = results['reference'] as String;
    bool loadAllSets = results['all-sets'] as bool;
    bool verbose = results['verbose'] as bool;
    bool visual = results['visual'] as bool;
    // Create output directory if it doesn't exist
    Directory outputDir = Directory(outputPath);
    if (!await outputDir.exists()) {
      await outputDir.create(recursive: true);
      info('Created output directory: $outputPath');
    }
    // Initialize the card detector
    MagicCardDetector detector = MagicCardDetector(outputPath: outputPath);
    detector.verbose = verbose;
    detector.visual = visual;
    // Load reference data
    try {
      if (loadAllSets) {
        info('Loading all available set hashes...');
        await detector.loadAllSetHashes();
      } else {
        info('Loading reference hash file: $refHashPath');
        await detector.readPrehashReferenceData(refHashPath);
      }
      
      info('Loaded ${detector.referenceImages.length} reference cards in total.');
    } catch (e) {
      error('Error loading reference data: $e');
      error('Please make sure the reference hash file(s) exist and are valid.');
      exit(1);
    }
    // Check if input is a file or directory
    File inputFile = File(inputPath);
    Directory inputDir = Directory(inputPath);
    
    if (await inputFile.exists()) {
      // Process a single image
      info('Processing single image: $inputPath');
      
      try {
        Uint8List bytes = await inputFile.readAsBytes();
        List<Uint8List> results = await detector.processImage(bytes, path.basename(inputPath));
        
        // Save original and annotated images
        String name = path.basenameWithoutExtension(inputPath);
        
        await File(path.join(outputPath, '${name}_original.jpg')).writeAsBytes(results[0]);
        await File(path.join(outputPath, '${name}_result.jpg')).writeAsBytes(results[1]);
        
        success('Processing complete. Results saved to $outputPath');
      } catch (e) {
        error('Error processing image: $e');
        exit(1);
      }
    } else if (await inputDir.exists()) {
      // Process a directory of images
      info('Processing images in directory: $inputPath');
      
      try {
        await detector.readAndAdjustTestImages(inputPath);
        await detector.runRecognition();
        
        success('Processing complete. Results saved to $outputPath');
      } catch (e) {
        error('Error processing images: $e');
        exit(1);
      }
    } else {
      error('Error: Input path does not exist: $inputPath');
      exit(1);
    }
  } catch (e) {
    error('Error: $e');
    printUsage(parser);
    exit(1);
  }
}
void printUsage(ArgParser parser) {
  info('Magic Card Detector - Dart Implementation');
  info('Usage: magic_card_detector [options]');
  info(parser.usage);
}